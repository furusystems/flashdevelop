/*
License:
  Currently there's no license restriction.You could use,modify it as you like.:)

*/
/*
@Author He.Ye (email:heyesh@cn.ibm.com)

Known Issue that is incompatible with Ecma-262(ECMAScript3 Specification)
1.[Lexer rule]RegularExpressionFirstChar must NOT be > , to avoid the consusable with XML Literal />

Known Issue that is incompatible with Ecma-357(ECMAScript for XML (E4X) Specification)
1. XMLName Lexer rule follows Ecma-262 Identifier rule (BUT can be a Reserved Word)

November 2008: Ernest Pasour - patched to add 'void' type as a valid function return type.
                             - interleaved helper code into grammar for purposes of supporting format/indent tool.
                             - changed memberExpression, callExpression and several others to use code from another grammar that handles function calls correctly.
                             - added ability to parse namespaces (double colon) in the code. ex. mOutputArea.mx_internal::getTextField();
                             - added support for binding declarations. ex. [Exclude(name="horizontalScrollBarStyleName", kind="style")]
                                                                           [IconFile("Accordion.png")] 
                                                                           [RequiresDataBinding(true)]
                             - added support for include directives
                             - added support for 'is' operator
                             - added support for '.*' in imports
                             - added support of 'as' operator
                             - added 'use namespace' directive
                             - added default xml namespace directive
                             - fixed implements to take a typeList instead of just a single type
                             - fixed formalParameterList to allow a single parameter that is an ellipsis
                             - added fileContents rule to allow a package declaration plus any combination of classes/interfaces/statements/directives afterward (i.e. outside the package)
                             	-I think this is the change that forced me to add -Xmx512m on the command line to prevent JDK OutOfMemoryError while processing the file.
                             - fixed identifierLiteral to allow keywords that aren't reserved
                             - fixed to allow xml attribute to allow any keyword to be used as an attribute name
                             - added support for xml attribute expressions ( ex. x.y.(@name=="abc").Length); )
                             - changed code that handles virtual semicolon to do lookahead for EOL/LineComment/MLComment instead of promoting token from non-hidden to hidden, which causes problems with the parser prediction phase
                             - fixed to allow trailing commas in array specifier, since that seems to be legal
January 2009				 - fixed to allow type specifier on ellipsis parameter.  Ex. override flash_proxy function callProperty(name:*, ... args:Array):*
February 2009				 - removed MUL_ASSIGN because of ambiguity with '*' type: ex. var x:*=2;
March 2009                   - added support for double negation ex. !!true or ~~true
                             - added support for conditional compiler code (ex. Config::debug {})
April 2009                   - added missing operators &&= and ||=
                             - added support for nested Vector declarations.  (ex. var nssets:Vector.<Vector.<String>> = new Vector.<Vector.<String>>(n+1);)
May 2009					 - fixed e4x to handle tagnames/attributes with hyphens/dots/colons (ex. <array-table></array-table>
							 - fixed e4x to allow var layers:XMLList = xmlData..ns::g.(@inkscape::groupmode =="layer");                             
June 2009                    - added ability to not indent at package level.  This is the way Adobe's example code is done, although the auto indent on carriage return in their editor doesn't agree
                             - added support for methods named "get" and "set".  I didn't think it was legal, but it appears to be.  This makes the grammar a little ambiguous, but it seems to work.
August 2009                  - added support for e4x attr names that are variable expressions.  Ex. <foo {attr}="value"/>
                             - added support for conditional blocks at the member level.  Ex. around a function or variable.  Grammar changes for packageElement and mxmlEmbedded, to support both AS classes and AS code fragments embedded within mxml.
October 2009                 - added support for using namespace to access members  Ex. mx_internal::functionCall(true);    
December 2009				 - fixed classBodyElement and interfaceElement to handle conditional blocks around their elements
                             - reordered labelledStatement, emptyStatement, and expression statement to be at end of statement rule so
                             	    that all the items with keyword lookahead get processed first.  There were some issues with labelled
                             	    statements that just started cropping up when I made minor changes.
                             - fixed findVirtualTokens to kick out early if the current token is one of the handled tokens (;, EOF, }) rather
                                    than performing the search for a virtual semicolon regardless.
                             - changed to require a VAR keyword before decl in for initializer.  Grammar was ambiguous before.       
                             - removed enumeration of particular string escape sequences because the compiler does "the right thing" under the covers.
                             - changed UNDERSCORE and DOLLAR to fragments because they are legal by themselves as identifiers, but the lexer was treating them as a top level token instead of part of the IDENTIFIER rule
January 2010                 - added -/+ to numeric literal for bindable arguments.  The parse didn't fail, but the item wasn't treated as a metadata tag.
July 2010                    - fixed metatags to allow keywords to be used as attributes (ex. [Inspectable(category="Style", default="1")] )
August 2010                  - fixed Vector to allow array initializer. ex. var v:Vector.<int>=new < int > [1, 2, 3]; 
September 2010				 - added support for Vector.<*>
                             - added support for (sharedDataViz.dataKind)::entitySortField
November 2010                - added support for metatag with scoped identifiers (ex. [MessageHandler(selector=MessageChannel.PNL)])
							 - added handling for non-breaking space char (00a0), which is apparently legal in actionscript files
							 - added ability to handle regular expressions containing '>'.  Ex. />abc/g
March 2011                   - nwo allow metatags that start with @ (ex. @Embed).  Not sure if this is really legal or not.						 							 
Currently building with Antlr 3.1.1                              
                             
*/
grammar AS3_ex;
options
{
    backtrack=true;
    memoize=true;
    output=AST;
    language=CSharp;
}

tokens{
    AS          =   'as';
    BREAK       =   'break';
    CASE        =   'case';
    CATCH       =   'catch';
    CLASS       =   'class';
    CONST       =   'const';
    CONTINUE    =   'continue';
    DEFAULT     =   'default';
    DELETE      =   'delete';
    DO          =   'do';
    ELSE        =   'else';
    EXTENDS     =   'extends';
    FALSE       =   'false';
    FINALLY     =   'finally';
    FOR         =   'for';
    FUNCTION    =   'function';
    IF          =   'if';
    IMPLEMENTS  =   'implements';
    IMPORT      =   'import';
    IN          =   'in';
    INSTANCEOF  =   'instanceof';
    INTERFACE   =   'interface';
    INTERNAL    =   'internal';
    IS          =   'is';
    NATIVE      =   'native';
    NEW         =   'new';
    NULL        =   'null';
    PACKAGE     =   'package';  
    PRIVATE     =   'private';
    PROTECTED   =   'protected';
    PUBLIC      =   'public';
    RETURN      =   'return';
    SUPER       =   'super';
    SWITCH      =   'switch';
    THIS        =   'this';
    THROW       =   'throw';
    TO          =   'to';
    TRUE        =   'true';
    TRY         =   'try';
    TYPEOF      =   'typeof';
    USE         =   'use';
    VAR         =   'var';
    VOID        =   'void';
    WHILE       =   'while';
    WITH        =   'with';
    
    // KEYWORDs but can be identifier
    EACH        =   'each';
    GET         =   'get';
    SET         =   'set';
    NAMESPACE   =   'namespace';
    INCLUDE     =   'include';
    DYNAMIC     =   'dynamic';
    FINAL       =   'final';
    OVERRIDE    =   'override';
    STATIC      =   'static';
    
    // Future KEYWORDS
    //ABSTRACT    =   'abstract';
    //BOOLEAN     =   'boolean';
    //BYTE        =   'byte';
    //CAST        =   'cast';
    //CHAR        =   'char';
    //DEBUGGER    =   'debugger';
    //DOUBLE      =   'double';
    //ENUM        =   'enum';
    //EXPORT      =   'export';
    //FLOAT       =   'float';
    //GOTO        =   'goto';
    //INTRINSIC   =   'intrinsic';
    //LONG        =   'long';
    //PROTOTYPE   =   'prototype';
    //SHORT       =   'short';
    //SYNCHRONIZED=   'synchronized';
    //THROWS      =   'throws';
    //TO          =   'to';
    //TRANSIENT   =   'transient';
    //TYPE        =   'type';
    //VIRTUAL     =   'virtual';
    //VOLATILE    =   'volatile';
    
    SEMI        = ';' ;
    LCURLY      = '{' ;
    RCURLY      = '}' ;
    LPAREN      = '(' ;
    RPAREN      = ')' ;
    LBRACK      = '[' ;
    RBRACK      = ']' ;
    DOT         = '.' ;
    COMMA       = ',' ;
    LT          = '<' ;
    GT          = '>' ;
    LTE         = '<=' ;
    GTE; //         = '>=' ;
    EQ          = '==' ;
    NEQ         = '!=' ;
    SAME        = '===' ;
    NSAME       = '!==' ;
    PLUS        = '+' ;
    SUB         = '-' ;
    STAR        = '*' ;
    DIV         = '/' ; 
    MOD         = '%' ;
    INC         = '++' ;
    DEC         = '--' ;
    SHL         = '<<' ;
    SHR;//         = '>>' ;
    SHU;//         = '>>>' ;
    AND         = '&' ;
    OR          = '|' ;
    XOR         = '^' ;
    NOT         = '!' ;
    INV         = '~' ;
    LAND        = '&&' ;
    LOR         = '||' ;
    QUE         = '?' ;
    COLON       = ':' ;
    ASSIGN      = '=' ;
//    MUL_ASSIGN  = '*=' ;
    DIV_ASSIGN  = '/=' ;
    MOD_ASSIGN  = '%=' ;
    ADD_ASSIGN  = '+=' ;
    SUB_ASSIGN  = '-=' ;
    SHL_ASSIGN  = '<<=';
    SHR_ASSIGN;//  = '>>=';
    SHU_ASSIGN;//  = '>>>=';
    LAND_ASSIGN = '&&=';
    LOR_ASSIGN  = '||=';
    AND_ASSIGN  = '&=' ;
    XOR_ASSIGN  = '^=' ;
    OR_ASSIGN   = '|=' ;
    ELLIPSIS    = '...';
    XML_ELLIPSIS='..';
    XML_TEND    = '/>';
    XML_E_TEND  = '</';
    XML_NS_OP   = '::';
    XML_AT      = '@';
    XML_LS_STD  = '<>';
    XML_LS_END  = '</>';
}
@header
{
using System.Linq;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using CodeFormatter.InfoCollector;
using CodeFormatter.Handlers;
using PluginCore.Managers;

#pragma warning disable 162
#pragma warning disable 414
#pragma warning disable 219
}
@lexer::header
{
using System.Linq;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using CodeFormatter.InfoCollector;
using CodeFormatter.Handlers;
using PluginCore.Managers;
}
@lexer::members
{
    /**  */
    private IToken lastDefaultCnlToken = null;
    
    // override
    override public IToken NextToken()
    {
        IToken result = base.NextToken();
        if (result!=null && result.Channel != AS3_exParser.CHANNEL_WHITESPACE )
        {
            lastDefaultCnlToken = result;
        }
        return result;      
    }
    
	override public void Reset()
	{
		base.Reset(); // reset all recognizer state variables
		if (input is ANTLRStringStream)
		{
			((ANTLRStringStream)input).Reset();
		}
	}
    

	//TODO: fix this so that regular expression embedded within xml text will work
    private bool isRegularExpression(){
        if(lastDefaultCnlToken!=null){
            switch(lastDefaultCnlToken.Type){
                case NULL :
                case TRUE :
                case FALSE:
                case THIS :
                case SUPER:
                case IDENTIFIER:
                case HEX_NUMBER_LITERAL:
                case DEC_NUMBER_LITERAL:
                case SINGLE_QUOTE_LITERAL:
                case DOUBLE_QUOTE_LITERAL:
                case RCURLY:
                case RBRACK:
                case RPAREN:
                	//this is an attempt to not think something is a regular expression if it happens
                	//to be part of a mathematical expression.
                    return false;
                default:
                    break;
            }
        }

        //System.out.println("start to predict if is a RegularExpression");
        // start to predict if the next is a regular expression
        int next = -1;
        int index=1;
        bool success = false;
        if((next=input.LA(index)) != '/'){
            success = false;
            return success;
        }
        index++;
        // check the first regular character
        next=input.LA(index);
        if(next == '\r' || next == '\n' || 
        	next == '*' || //starts a comment
        	next == '/'  //if no regex content?
        	//|| next == '>' //I think the idea of failing on /> is to prevent conflicts with other tokens, but I think that is irrelevant since I've made this context sensitive.
         	){
            success = false;
            return success;
        }else if(next == '\\'){
            next=input.LA(index+1);
            if(next == '\r' || next == '\n'){
                success=false;
                return success;
            }
            // we omit the escape sequence \ u XXXX or \ x XX
            index++;
        }
        index++;
        // check the body of regular character
        while((next=input.LA(index))!=-1){
            ////System.out.println("char["+index+"] = ("+(char)next+")");
            switch(next){
                case '\r':
                case '\n':
                    success = false;
                    return success;
                case '\\':
                    next=input.LA(index+1);
                    if(next == '\r' || next == '\n'){
                        success=false;
                        return success;
                    }
                    // we omit the escape sequence \ u XXXX or \ x XX
                    index++;
                    break;
                case '/':
                    success = true;
                    return success;
            }            
            index++;
        }
        return success;
    }
        
   /**
    * <pre> judge if is a XMLName </pre>
    * @param ch character
    * @return if is a XMLName return true
    */
    static bool isXMLText(int ch){
        //System.out.println("isXMLText start");
        return (ch!='{'&&ch!='<'&&!(isUnicodeIdentifierPart(ch)));
    }
        
	/*---------------------------UNICODE_INDENTIFER START------------------------------------------*/    
	
	private static bool isUnicodeIdentifierPart(int ch)
	{
		return ch=='$'||ch=='_'||isUnicodeLetter(ch)||isUnicodeDigit(ch)||isUnicodeCombiningMark(ch)||isUnicodeConnectorPunctuation(ch);
	}

	private void consumeIdentifierUnicodeStart() 
	{
		int ch = input.LA(1);
		if (isUnicodeLetter(ch) || ch=='$' || ch=='_')
		{
			MatchAny();
			do
			{
				ch = input.LA(1);
				if (isUnicodeIdentifierPart(ch))
				{
					mIDENT_PART();
				}
				else
				{
					return;
				}
			}
			while (true);
		}
	}
	
	private static bool isUnicodeLetter(int ch) 
	{
		return (ch >= '\u0041' && ch <= '\u005A')
				|| (ch >= '\u0061' && ch <= '\u007A') || (ch == '\u00AA')
				|| (ch == '\u00B5') || (ch == '\u00BA')
				|| (ch >= '\u00C0' && ch <= '\u00D6')
				|| (ch >= '\u00D8' && ch <= '\u00F6')
				|| (ch >= '\u00F8' && ch <= '\u02C1')
				|| (ch >= '\u02C6' && ch <= '\u02D1')
				|| (ch >= '\u02E0' && ch <= '\u02E4') || (ch == '\u02EC')
				|| (ch == '\u02EE') || (ch >= '\u0370' && ch <= '\u0374')
				|| (ch >= '\u0376' && ch <= '\u037D') || (ch == '\u0386')
				|| (ch >= '\u0388' && ch <= '\u03F5')
				|| (ch >= '\u03F7' && ch <= '\u0481')
				|| (ch >= '\u048A' && ch <= '\u0559')
				|| (ch >= '\u0561' && ch <= '\u0587')
				|| (ch >= '\u05D0' && ch <= '\u05F2')
				|| (ch >= '\u0621' && ch <= '\u064A')
				|| (ch >= '\u066E' && ch <= '\u066F')
				|| (ch >= '\u0671' && ch <= '\u06D3') || (ch == '\u06D5')
				|| (ch >= '\u06E5' && ch <= '\u06E6')
				|| (ch >= '\u06EE' && ch <= '\u06EF')
				|| (ch >= '\u06FA' && ch <= '\u06FC') || (ch == '\u06FF')
				|| (ch == '\u0710') || (ch >= '\u0712' && ch <= '\u072F')
				|| (ch >= '\u074D' && ch <= '\u07A5') || (ch == '\u07B1')
				|| (ch >= '\u07CA' && ch <= '\u07EA')
				|| (ch >= '\u07F4' && ch <= '\u07F5') || (ch == '\u07FA')
				|| (ch >= '\u0904' && ch <= '\u0939') || (ch == '\u093D')
				|| (ch == '\u0950') || (ch >= '\u0958' && ch <= '\u0961')
				|| (ch >= '\u0971' && ch <= '\u097F')
				|| (ch >= '\u0985' && ch <= '\u09B9') || (ch == '\u09BD')
				|| (ch == '\u09CE') || (ch >= '\u09DC' && ch <= '\u09E1')
				|| (ch >= '\u09F0' && ch <= '\u09F1')
				|| (ch >= '\u0A05' && ch <= '\u0A39')
				|| (ch >= '\u0A59' && ch <= '\u0A5E')
				|| (ch >= '\u0A72' && ch <= '\u0A74')
				|| (ch >= '\u0A85' && ch <= '\u0AB9') || (ch == '\u0ABD')
				|| (ch >= '\u0AD0' && ch <= '\u0AE1')
				|| (ch >= '\u0B05' && ch <= '\u0B39') || (ch == '\u0B3D')
				|| (ch >= '\u0B5C' && ch <= '\u0B61') || (ch == '\u0B71')
				|| (ch >= '\u0B83' && ch <= '\u0BB9') || (ch == '\u0BD0')
				|| (ch >= '\u0C05' && ch <= '\u0C3D')
				|| (ch >= '\u0C58' && ch <= '\u0C61')
				|| (ch >= '\u0C85' && ch <= '\u0CB9') || (ch == '\u0CBD')
				|| (ch >= '\u0CDE' && ch <= '\u0CE1')
				|| (ch >= '\u0D05' && ch <= '\u0D3D')
				|| (ch >= '\u0D60' && ch <= '\u0D61')
				|| (ch >= '\u0D7A' && ch <= '\u0D7F')
				|| (ch >= '\u0D85' && ch <= '\u0DC6')
				|| (ch >= '\u0E01' && ch <= '\u0E30')
				|| (ch >= '\u0E32' && ch <= '\u0E33')
				|| (ch >= '\u0E40' && ch <= '\u0E46')
				|| (ch >= '\u0E81' && ch <= '\u0EB0')
				|| (ch >= '\u0EB2' && ch <= '\u0EB3')
				|| (ch >= '\u0EBD' && ch <= '\u0EC6')
				|| (ch >= '\u0EDC' && ch <= '\u0F00')
				|| (ch >= '\u0F40' && ch <= '\u0F6C')
				|| (ch >= '\u0F88' && ch <= '\u0F8B')
				|| (ch >= '\u1000' && ch <= '\u102A') || (ch == '\u103F')
				|| (ch >= '\u1050' && ch <= '\u1055')
				|| (ch >= '\u105A' && ch <= '\u105D') || (ch == '\u1061')
				|| (ch >= '\u1065' && ch <= '\u1066')
				|| (ch >= '\u106E' && ch <= '\u1070')
				|| (ch >= '\u1075' && ch <= '\u1081') || (ch == '\u108E')
				|| (ch >= '\u10A0' && ch <= '\u10FA')
				|| (ch >= '\u10FC' && ch <= '\u135A')
				|| (ch >= '\u1380' && ch <= '\u138F')
				|| (ch >= '\u13A0' && ch <= '\u166C')
				|| (ch >= '\u166F' && ch <= '\u1676')
				|| (ch >= '\u1681' && ch <= '\u169A')
				|| (ch >= '\u16A0' && ch <= '\u16EA')
				|| (ch >= '\u16EE' && ch <= '\u1711')
				|| (ch >= '\u1720' && ch <= '\u1731')
				|| (ch >= '\u1740' && ch <= '\u1751')
				|| (ch >= '\u1760' && ch <= '\u1770')
				|| (ch >= '\u1780' && ch <= '\u17B3') || (ch == '\u17D7')
				|| (ch == '\u17DC') || (ch >= '\u1820' && ch <= '\u18A8')
				|| (ch >= '\u18AA' && ch <= '\u191C')
				|| (ch >= '\u1950' && ch <= '\u19A9')
				|| (ch >= '\u19C1' && ch <= '\u19C7')
				|| (ch >= '\u1A00' && ch <= '\u1A16')
				|| (ch >= '\u1B05' && ch <= '\u1B33')
				|| (ch >= '\u1B45' && ch <= '\u1B4B')
				|| (ch >= '\u1B83' && ch <= '\u1BA0')
				|| (ch >= '\u1BAE' && ch <= '\u1BAF')
				|| (ch >= '\u1C00' && ch <= '\u1C23')
				|| (ch >= '\u1C4D' && ch <= '\u1C4F')
				|| (ch >= '\u1C5A' && ch <= '\u1C7D')
				|| (ch >= '\u1D00' && ch <= '\u1DBF')
				|| (ch >= '\u1E00' && ch <= '\u1FBC') || (ch == '\u1FBE')
				|| (ch >= '\u1FC2' && ch <= '\u1FCC')
				|| (ch >= '\u1FD0' && ch <= '\u1FDB')
				|| (ch >= '\u1FE0' && ch <= '\u1FEC')
				|| (ch >= '\u1FF2' && ch <= '\u1FFC') || (ch == '\u2071')
				|| (ch == '\u207F') || (ch >= '\u2090' && ch <= '\u2094')
				|| (ch == '\u2102') || (ch == '\u2107')
				|| (ch >= '\u210A' && ch <= '\u2113') || (ch == '\u2115')
				|| (ch >= '\u2119' && ch <= '\u211D') || (ch == '\u2124')
				|| (ch == '\u2126') || (ch == '\u2128')
				|| (ch >= '\u212A' && ch <= '\u212D')
				|| (ch >= '\u212F' && ch <= '\u2139')
				|| (ch >= '\u213C' && ch <= '\u213F')
				|| (ch >= '\u2145' && ch <= '\u2149') || (ch == '\u214E')
				|| (ch >= '\u2160' && ch <= '\u2188')
				|| (ch >= '\u2C00' && ch <= '\u2CE4')
				|| (ch >= '\u2D00' && ch <= '\u2DDE') || (ch == '\u2E2F')
				|| (ch >= '\u3005' && ch <= '\u3007')
				|| (ch >= '\u3021' && ch <= '\u3029')
				|| (ch >= '\u3031' && ch <= '\u3035')
				|| (ch >= '\u3038' && ch <= '\u303C')
				|| (ch >= '\u3041' && ch <= '\u3096')
				|| (ch >= '\u309D' && ch <= '\u309F')
				|| (ch >= '\u30A1' && ch <= '\u30FA')
				|| (ch >= '\u30FC' && ch <= '\u318E')
				|| (ch >= '\u31A0' && ch <= '\u31B7')
				|| (ch >= '\u31F0' && ch <= '\u31FF')
				|| (ch >= '\u3400' && ch <= '\u4DB5')
				|| (ch >= '\u4E00' && ch <= '\uA48C')
				|| (ch >= '\uA500' && ch <= '\uA60C')
				|| (ch >= '\uA610' && ch <= '\uA61F')
				|| (ch >= '\uA62A' && ch <= '\uA66E')
				|| (ch >= '\uA67F' && ch <= '\uA697')
				|| (ch >= '\uA717' && ch <= '\uA71F')
				|| (ch >= '\uA722' && ch <= '\uA788')
				|| (ch >= '\uA78B' && ch <= '\uA801')
				|| (ch >= '\uA803' && ch <= '\uA805')
				|| (ch >= '\uA807' && ch <= '\uA80A')
				|| (ch >= '\uA80C' && ch <= '\uA822')
				|| (ch >= '\uA840' && ch <= '\uA873')
				|| (ch >= '\uA882' && ch <= '\uA8B3')
				|| (ch >= '\uA90A' && ch <= '\uA925')
				|| (ch >= '\uA930' && ch <= '\uA946')
				|| (ch >= '\uAA00' && ch <= '\uAA28')
				|| (ch >= '\uAA40' && ch <= '\uAA42')
				|| (ch >= '\uAA44' && ch <= '\uAA4B')
				|| (ch >= '\uAC00' && ch <= '\uD7A3')
				|| (ch >= '\uF900' && ch <= '\uFB1D')
				|| (ch >= '\uFB1F' && ch <= '\uFB28')
				|| (ch >= '\uFB2A' && ch <= '\uFD3D')
				|| (ch >= '\uFD50' && ch <= '\uFDFB')
				|| (ch >= '\uFE70' && ch <= '\uFEFC')
				|| (ch >= '\uFF21' && ch <= '\uFF3A')
				|| (ch >= '\uFF41' && ch <= '\uFF5A')
				|| (ch >= '\uFF66' && ch <= '\uFFDC');
	}
	
	private static bool isUnicodeCombiningMark(int ch) 
	{
    		return (ch >= '\u0300' && ch <= '\u036F')
    				|| (ch >= '\u0483' && ch <= '\u0487')
    				|| (ch >= '\u0591' && ch <= '\u05BD') || (ch == '\u05BF')
    				|| (ch >= '\u05C1' && ch <= '\u05C2')
    				|| (ch >= '\u05C4' && ch <= '\u05C5') || (ch == '\u05C7')
    				|| (ch >= '\u0610' && ch <= '\u061A')
    				|| (ch >= '\u064B' && ch <= '\u065E') || (ch == '\u0670')
    				|| (ch >= '\u06D6' && ch <= '\u06DC')
    				|| (ch >= '\u06DF' && ch <= '\u06E4')
    				|| (ch >= '\u06E7' && ch <= '\u06E8')
    				|| (ch >= '\u06EA' && ch <= '\u06ED') || (ch == '\u0711')
    				|| (ch >= '\u0730' && ch <= '\u074A')
    				|| (ch >= '\u07A6' && ch <= '\u07B0')
    				|| (ch >= '\u07EB' && ch <= '\u07F3')
    				|| (ch >= '\u0901' && ch <= '\u0903') || (ch == '\u093C')
    				|| (ch >= '\u093E' && ch <= '\u094D')
    				|| (ch >= '\u0951' && ch <= '\u0954')
    				|| (ch >= '\u0962' && ch <= '\u0963')
    				|| (ch >= '\u0981' && ch <= '\u0983') || (ch == '\u09BC')
    				|| (ch >= '\u09BE' && ch <= '\u09CD') || (ch == '\u09D7')
    				|| (ch >= '\u09E2' && ch <= '\u09E3')
    				|| (ch >= '\u0A01' && ch <= '\u0A03')
    				|| (ch >= '\u0A3C' && ch <= '\u0A51')
    				|| (ch >= '\u0A70' && ch <= '\u0A71')
    				|| (ch >= '\u0A75' && ch <= '\u0A83') || (ch == '\u0ABC')
    				|| (ch >= '\u0ABE' && ch <= '\u0ACD')
    				|| (ch >= '\u0AE2' && ch <= '\u0AE3')
    				|| (ch >= '\u0B01' && ch <= '\u0B03') || (ch == '\u0B3C')
    				|| (ch >= '\u0B3E' && ch <= '\u0B57')
    				|| (ch >= '\u0B62' && ch <= '\u0B63') || (ch == '\u0B82')
    				|| (ch >= '\u0BBE' && ch <= '\u0BCD') || (ch == '\u0BD7')
    				|| (ch >= '\u0C01' && ch <= '\u0C03')
    				|| (ch >= '\u0C3E' && ch <= '\u0C56')
    				|| (ch >= '\u0C62' && ch <= '\u0C63')
    				|| (ch >= '\u0C82' && ch <= '\u0C83') || (ch == '\u0CBC')
    				|| (ch >= '\u0CBE' && ch <= '\u0CD6')
    				|| (ch >= '\u0CE2' && ch <= '\u0CE3')
    				|| (ch >= '\u0D02' && ch <= '\u0D03')
    				|| (ch >= '\u0D3E' && ch <= '\u0D57')
    				|| (ch >= '\u0D62' && ch <= '\u0D63')
    				|| (ch >= '\u0D82' && ch <= '\u0D83')
    				|| (ch >= '\u0DCA' && ch <= '\u0DF3') || (ch == '\u0E31')
    				|| (ch >= '\u0E34' && ch <= '\u0E3A')
    				|| (ch >= '\u0E47' && ch <= '\u0E4E') || (ch == '\u0EB1')
    				|| (ch >= '\u0EB4' && ch <= '\u0EBC')
    				|| (ch >= '\u0EC8' && ch <= '\u0ECD')
    				|| (ch >= '\u0F18' && ch <= '\u0F19') || (ch == '\u0F35')
    				|| (ch == '\u0F37') || (ch == '\u0F39')
    				|| (ch >= '\u0F3E' && ch <= '\u0F3F')
    				|| (ch >= '\u0F71' && ch <= '\u0F84')
    				|| (ch >= '\u0F86' && ch <= '\u0F87')
    				|| (ch >= '\u0F90' && ch <= '\u0FBC') || (ch == '\u0FC6')
    				|| (ch >= '\u102B' && ch <= '\u103E')
    				|| (ch >= '\u1056' && ch <= '\u1059')
    				|| (ch >= '\u105E' && ch <= '\u1060')
    				|| (ch >= '\u1062' && ch <= '\u1064')
    				|| (ch >= '\u1067' && ch <= '\u106D')
    				|| (ch >= '\u1071' && ch <= '\u1074')
    				|| (ch >= '\u1082' && ch <= '\u108D') || (ch == '\u108F')
    				|| (ch == '\u135F') || (ch >= '\u1712' && ch <= '\u1714')
    				|| (ch >= '\u1732' && ch <= '\u1734')
    				|| (ch >= '\u1752' && ch <= '\u1753')
    				|| (ch >= '\u1772' && ch <= '\u1773')
    				|| (ch >= '\u17B6' && ch <= '\u17D3') || (ch == '\u17DD')
    				|| (ch >= '\u180B' && ch <= '\u180D') || (ch == '\u18A9')
    				|| (ch >= '\u1920' && ch <= '\u193B')
    				|| (ch >= '\u19B0' && ch <= '\u19C0')
    				|| (ch >= '\u19C8' && ch <= '\u19C9')
    				|| (ch >= '\u1A17' && ch <= '\u1A1B')
    				|| (ch >= '\u1B00' && ch <= '\u1B04')
    				|| (ch >= '\u1B34' && ch <= '\u1B44')
    				|| (ch >= '\u1B6B' && ch <= '\u1B73')
    				|| (ch >= '\u1B80' && ch <= '\u1B82')
    				|| (ch >= '\u1BA1' && ch <= '\u1BAA')
    				|| (ch >= '\u1C24' && ch <= '\u1C37')
    				|| (ch >= '\u1DC0' && ch <= '\u1DFF')
    				|| (ch >= '\u20D0' && ch <= '\u20DC') || (ch == '\u20E1')
    				|| (ch >= '\u20E5' && ch <= '\u20F0')
    				|| (ch >= '\u2DE0' && ch <= '\u2DFF')
    				|| (ch >= '\u302A' && ch <= '\u302F')
    				|| (ch >= '\u3099' && ch <= '\u309A') || (ch == '\uA66F')
    				|| (ch >= '\uA67C' && ch <= '\uA67D') || (ch == '\uA802')
    				|| (ch == '\uA806') || (ch == '\uA80B')
    				|| (ch >= '\uA823' && ch <= '\uA827')
    				|| (ch >= '\uA880' && ch <= '\uA881')
    				|| (ch >= '\uA8B4' && ch <= '\uA8C4')
    				|| (ch >= '\uA926' && ch <= '\uA92D')
    				|| (ch >= '\uA947' && ch <= '\uA953')
    				|| (ch >= '\uAA29' && ch <= '\uAA36') || (ch == '\uAA43')
    				|| (ch >= '\uAA4C' && ch <= '\uAA4D') || (ch == '\uFB1E')
    				|| (ch >= '\uFE00' && ch <= '\uFE0F')
    				|| (ch >= '\uFE20' && ch <= '\uFE26');
    	}

    	private static bool isUnicodeDigit(int ch) 
		{
    		return (ch >= '\u0030' && ch <= '\u0039')
    				|| (ch >= '\u0660' && ch <= '\u0669')
    				|| (ch >= '\u06F0' && ch <= '\u06F9')
    				|| (ch >= '\u07C0' && ch <= '\u07C9')
    				|| (ch >= '\u0966' && ch <= '\u096F')
    				|| (ch >= '\u09E6' && ch <= '\u09EF')
    				|| (ch >= '\u0A66' && ch <= '\u0A6F')
    				|| (ch >= '\u0AE6' && ch <= '\u0AEF')
    				|| (ch >= '\u0B66' && ch <= '\u0B6F')
    				|| (ch >= '\u0BE6' && ch <= '\u0BEF')
    				|| (ch >= '\u0C66' && ch <= '\u0C6F')
    				|| (ch >= '\u0CE6' && ch <= '\u0CEF')
    				|| (ch >= '\u0D66' && ch <= '\u0D6F')
    				|| (ch >= '\u0E50' && ch <= '\u0E59')
    				|| (ch >= '\u0ED0' && ch <= '\u0ED9')
    				|| (ch >= '\u0F20' && ch <= '\u0F29')
    				|| (ch >= '\u1040' && ch <= '\u1049')
    				|| (ch >= '\u1090' && ch <= '\u1099')
    				|| (ch >= '\u17E0' && ch <= '\u17E9')
    				|| (ch >= '\u1810' && ch <= '\u1819')
    				|| (ch >= '\u1946' && ch <= '\u194F')
    				|| (ch >= '\u19D0' && ch <= '\u19D9')
    				|| (ch >= '\u1B50' && ch <= '\u1B59')
    				|| (ch >= '\u1BB0' && ch <= '\u1BB9')
    				|| (ch >= '\u1C40' && ch <= '\u1C49')
    				|| (ch >= '\u1C50' && ch <= '\u1C59')
    				|| (ch >= '\uA620' && ch <= '\uA629')
    				|| (ch >= '\uA8D0' && ch <= '\uA909')
    				|| (ch >= '\uAA50' && ch <= '\uAA59')
    				|| (ch >= '\uFF10' && ch <= '\uFF19');
    	}

    	private static bool isUnicodeConnectorPunctuation(int ch) 
		{
    		return (ch == '\u005F') || (ch >= '\u203F' && ch <= '\u2040')
    				|| (ch == '\u2054') || (ch >= '\uFE33' && ch <= '\uFE34')
    				|| (ch >= '\uFE4D' && ch <= '\uFE4F') || (ch == '\uFF3F');
    	}

	/*---------------------------UNICODE_INDENTIFER END------------------------------------------*/
	
    private void debugMethod(String methodName,String text){
        //System.out.println("recognized as <<"+methodName+">> text=("+text+")");
    }    
}
@parser::members{
   
   		//options
private List<Exception> mParseErrors;
		
private ASPrettyPrinter mPrinter;
private CommonTokenStream mRawTokens;
private int mStatementCount=0;

private List<Int32> mCodeBlockStack=new List<Int32>(); //this is used for tracking which block I'm in so that I can handle the open brace differently depending on context
private bool mIsFunctionDecl; //flag that tells me whether the function body is associated with an expression or a declaration
private List<IfElseBlockTracker> mIfElseBlocks=new List<IfElseBlockTracker>();
private List<bool> mXMLTextContentStack=new List<bool>();

private bool mInFunctionParameterDecl=false; //set during formal parameter list so that I know where variable decls came from
private bool mInEqualAlignDecl=false; //only set to true for variable statement declarations (not ones in the parameter list, for loops, etc.)

public AS3_exParser(ASPrettyPrinter printer, CommonTokenStream tokenStream) : this(tokenStream, new RecognizerSharedState())
{
	mRawTokens=tokenStream;
    mPrinter=printer;
    mStatementCount=0;
}

public class IfElseBlockTracker
{
	public bool mBlockFlag=false;
	public bool mBlockFlagSet=false;
}

public void addIfElseBlockTracker()
{
	mIfElseBlocks.Add(new IfElseBlockTracker());
}

public void popIfElseBlockTracker()
{
	if (mIfElseBlocks.Count>0)
		mIfElseBlocks.RemoveAt(mIfElseBlocks.Count-1);
}

public IfElseBlockTracker getCurrentIfElseTracker()
{
	if (mIfElseBlocks.Count>0)
		return mIfElseBlocks[mIfElseBlocks.Count-1];
		
	return null;
}

public void setBlockFlag(bool flag)
{
	IfElseBlockTracker tracker=getCurrentIfElseTracker();
	if (tracker!=null)
	{
		//don't set if already set
		if (tracker.mBlockFlagSet)
			return;
			
		tracker.mBlockFlag=flag;
		tracker.mBlockFlagSet=true;
	}
}

public void markBlockFlag()
{
	IfElseBlockTracker tracker=getCurrentIfElseTracker();
	if (tracker!=null)
		tracker.mBlockFlagSet=true;
}

public void clearBlockFlag()
{
	IfElseBlockTracker tracker=getCurrentIfElseTracker();
	if (tracker!=null)
		tracker.mBlockFlagSet=false;
}

public bool isBlockFlag()
{
	IfElseBlockTracker tracker=getCurrentIfElseTracker();
	if (tracker!=null)
		return tracker.mBlockFlag;
		
	return false;
}

private void popBlockStack()
{
	if (mCodeBlockStack.Count>0)
	{
		mCodeBlockStack.RemoveAt(mCodeBlockStack.Count-1);
	}
}

private void setXMLTextContentFlag()
{
	if (mXMLTextContentStack.Count>0)
	{
		mXMLTextContentStack[mXMLTextContentStack.Count-1] = true;
	}
}

private void pushXMLTextContentFlag()
{
	mXMLTextContentStack.Add(false);
}

private bool popXMLTextContentFlag()
{
	if (mXMLTextContentStack.Count>0)
	{
		int index=mXMLTextContentStack.Count-1;
		bool value=mXMLTextContentStack[index];
		mXMLTextContentStack.RemoveAt(index);
		return value;
	}
	return false;
}

private void emitXMLBreak(IToken tok, bool before)
{
	WrapOptions options=mPrinter.getXMLWrapOptions();
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS))
	{
		mPrinter.saveWrapChar(tok, ASPrettyPrinter.Break_XML_code, before, false, -1, "");
	}
}

public bool foundNextLT()
{
   int i=1;
   while (true)
   {
       IToken token=input.LT(i);
       if (token.Text!=null && token.Text.StartsWith("<"))
          return (i>1);
       if (token.Type==EOF)
          return false;
       i++;   
   }
}

public void changeTokensUpToNextLT()
{
   int i=1;
   while (true)
   {
       IToken t=input.LT(i);
       if (t.Text!=null && t.Text.StartsWith("<"))
          return;
       if (t.Type==EOF)
          return;
       t.Type = XML_TEXT;          
          
       i++;   
   }
}

//this is for '.' and other similar characters that might cause a break
private void wrapEmit(IToken item, int breakType)
{
	pushExpressionIndent(); //needs to be matched with a popIndent later
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	bool breakBefore=options.isBeforeSeparator();
	if (breakType==ASPrettyPrinter.Break_Assignment_code || breakType==ASPrettyPrinter.Break_Parameter_Assignment_code)
		breakBefore=options.isBeforeAssignmentOperator();
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && breakBefore)
	{
		insertMaxColumnCR();
	}
	emit(item);
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && !breakBefore)
	{
		insertMaxColumnCR();
	}
	
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS))
	{
		mPrinter.saveWrapChar(item, breakType, (breakType==ASPrettyPrinter.Break_Keyword_code) ? true : breakBefore, false, -1, "");
	}
}

//this is for binary operators
private void indentEmit(IToken operatoR, int breakType)
{
	pushExpressionIndent(); //needs to be matched with a popIndent later
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	bool breakBefore=options.isBeforeSeparator();
	if (breakType==ASPrettyPrinter.Break_Arithmetic_Ops_code)
		breakBefore=options.isBeforeArithmeticOperator();
	else if (breakType==ASPrettyPrinter.Break_Logical_Ops_code || breakType==ASPrettyPrinter.Break_Ternary_code)
		breakBefore=options.isBeforeLogicalOperator();
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && breakBefore)
	{
		insertMaxColumnCR();
	}
	char firstChar=Convert.ToChar(0);
	if (operatoR.Text.Length>0)
		firstChar=operatoR.Text[0];
	if (firstChar!=0)
	{
		if (Utilities.isJavaIdentifierPart(firstChar.ToString()))
			insertWS(1); //add 1 space around text operators (ex. 'as', 'instanceof')
		else
			insertWS(mPrinter.getExpressionSpacesAroundSymbolicOperators()); //add configurable symbolic operator value
	}	
	emit(operatoR);
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && !breakBefore)
	{
		insertMaxColumnCR();
	}
	
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS))
	{
		mPrinter.saveWrapChar(operatoR, breakType, breakBefore, false, -1, "");
	}
	
	if (firstChar!=0)
	{
		if (Utilities.isJavaIdentifierPart(firstChar.ToString()))
			insertWS(1); //add 1 space around text operators (ex. 'as', 'instanceof')
		else
			insertWS(mPrinter.getExpressionSpacesAroundSymbolicOperators()); //add configurable symbolic operator value
	}	
}

private bool pushWrapInfo(WrapOptions options, bool newLevel)
{
	if (mPrinter.isDoFormat())
	{
		if (options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN)
		{
			mPrinter.createWrapContext(newLevel);
			return true;
		}
	}
	
	return false;
}

private bool pushFormatType(WrapOptions options, bool lazy)
{
	if (mPrinter.isDoFormat())
	{
		int formatMode=0;
		if (options.getWrapType()==WrapOptions.WRAP_DONT_PROCESS)
		{
			formatMode=ASPrettyPrinter.FORMAT_INDENT;
		}
		else if (options.getWrapType()==WrapOptions.WRAP_FORMAT_NO_CRs)
		{
			formatMode=ASPrettyPrinter.FORMAT_NOCRs;
		}
		else if (options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS)
		{
			formatMode=ASPrettyPrinter.FORMAT_OnlyAddCRs;
		}
		else
		{
			//if we didn't have a restrictive format, we want to make sure we're using the full format
			formatMode=ASPrettyPrinter.FORMAT_ALL;
		}

		if (formatMode>0)
		{
//		    if (formatMode==mPrinter.getFormatMode())
//		    	return false; //no need to nest format modes of the same type
		    	
			if (lazy)
				mPrinter.pushLazyFormat(formatMode);
			else
				mPrinter.pushFormatMode(formatMode);
			return true;
		}
		
	} 
	
	return false;
}

private void emitCRForTag(WrapOptions options)
{
	if (options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS)
	{
		insertMaxColumnCR();
	}
	else if (options.getWrapType()==WrapOptions.WRAP_BY_TAG)
	{
		insertCR(false);
	}

}

private bool emitCommaWithSpacingAndCRs(WrapOptions options, IToken comma, bool pushedIndent, int firstParmLocation, String contextType)
{
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && options.isBeforeSeparator())
	{
		insertMaxColumnCR();
	}
	
	if (!pushedIndent)
	{
		pushedIndent=true;
		pushExpressionIndent();
	}
	
    insertWS(mPrinter.getSpacesBeforeComma());
    emit(comma); 
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS) && !options.isBeforeSeparator())
	{
		insertMaxColumnCR();
	}
	if ((options.getWrapType()==WrapOptions.WRAP_BY_COLUMN || options.getWrapType()==WrapOptions.WRAP_BY_COLUMN_ONLY_ADD_CRS))
	{
		mPrinter.saveWrapChar(comma, ASPrettyPrinter.Break_Commas_code, options.isBeforeSeparator(), options.getIndentStyle()==WrapOptions.WRAP_STYLE_INDENT_TO_WRAP_ELEMENT, firstParmLocation, contextType);
	}
	insertWS(mPrinter.getSpacesAfterComma());
	return pushedIndent;
}

    public bool findVirtualHiddenToken(ParserRuleReturnScope retval)
    {
    		//the point of this method is to look for something that can serve as a semicolon.  So a carriage return
    		//or a comment containing a carriage return will fit the bill.
            int index = ((IToken)retval.Start).TokenIndex;
            if(index<0){
                index = input.Count;
            }
            else
            {
            	IToken lt=input.Get(index);
            	if (lt.Type==EOF || lt.Type==SEMI || lt.Type==RCURLY)
            		return false;
            }
            
/*            //we are on the next regular channel token after the rule.  So we walk backward to determine if between
            //the rule and this token is a single line comment, multiline comment, or new line that can serve as the
            //end token.  If so, then we 'promote' that token by returning it as the 'end' token of the rule (in place
            //of the semi colon).
	        for (int ix = index - 1; ix >= 0; ix--){
	            IToken lt = input.Get(ix);
	            int type = lt.Type;
	            if(lt.Channel == Token.DEFAULT_CHANNEL)
	                break;
	            if (type == EOL || type==COMMENT_SINGLELINE || (type == COMMENT_MULTILINE && Regex.Matches(lt.Text, "/.*\r\n|\r|\n").Count > 0))
	            {
	            	retval.Start=lt;
	                return true;
	            }
	        }*/
            
            
            //the token index is pointing to the next default channel token, which is not what we want.
            //We want to walk backward to the previous default channel token (first loop), and then walk forward
            //again looking for EOL/comments (2nd loop)
            int ix=index-1;
            for (; ix >= 0; ix--){
                IToken lt = input.Get(ix);
                if(lt.Channel == Token.DEFAULT_CHANNEL)
                    break;
            }
            
            //walk forward again
            ix++; //to move to next token that's not default channel
            for (;ix<input.Count;ix++) //now search for the next "statement ender"
            {
                IToken lt = input.Get(ix);
                int type = lt.Type;
                if (lt.Channel == Token.DEFAULT_CHANNEL)
                    break;
                if (type == EOL || type==COMMENT_SINGLELINE || (type == COMMENT_MULTILINE && Regex.Matches(lt.Text, "/.*\r\n|\r|\n").Count > 0))
                {
                	retval.Start=lt;
                    return true;
                }
            }

            return false;

    }

public void reportError(RecognitionException e)
{
    if (mParseErrors==null)
    	mParseErrors=new List<Exception>();
    mParseErrors.Add(e);
    //base.reportError(e);
}
		
private void insertWS(int amt)
{
    mPrinter.insertWS(amt);
}

private void insertLines(int amt)
{
	insertLines(amt, true);
}

private void insertVariableDeclAssignmentWhitespace(IToken equalToken, bool before)
{
	if (mPrinter.isDoFormat() && !mPrinter.isInParameterDecl() && mPrinter.isKeepingExcessDeclWhitespace())
	{
		int spaceCount=0;
		if (before)
		{
			IToken testToken=mRawTokens.Get(equalToken.TokenIndex-1);
			if (testToken.Channel==CHANNEL_WHITESPACE)
			{
				//if the token before the whitespace is a carriage return, we *don't* want to apply this "preserve whitespace" logic
				IToken prevTok=mRawTokens.Get(equalToken.TokenIndex-2);
				if (!(prevTok.Channel==CHANNEL_SLCOMMENT || prevTok.Channel==CHANNEL_EOL))
				{
					if (testToken.Text.IndexOf('\t')>=0)
					{
						spaceCount=mPrinter.getColumnForIndex(equalToken, 0)-mPrinter.getColumnForIndex(testToken, 0);
					}
					else
					{
					    spaceCount=testToken.Text.Length;
					}
				}
			}
		}
		else
		{
			IToken testToken=mRawTokens.Get(equalToken.TokenIndex+1);
			if (testToken.Channel==CHANNEL_WHITESPACE)
			{
				//if the token after the whitespace is a carriage return, we *don't* want to apply this "preserve whitespace" logic
				//I think we only care about actual EOL here, not sl comment or ml comment, since there is actual text before the CR,
				//even if it's not 'code' text.
				IToken nextTok=mRawTokens.Get(equalToken.TokenIndex+2);
				if (!(nextTok.Channel==CHANNEL_EOL))
				{
					if (testToken.Text.IndexOf('\t')>=0)
					{
						spaceCount=mPrinter.getColumnForIndex(testToken, testToken.Text.Length)-mPrinter.getColumnForIndex(equalToken, equalToken.Text.Length);
					}
					else
					{
					    spaceCount=testToken.Text.Length;
					}
				}
			}
		}
		
		if (spaceCount>mPrinter.getSpacesAroundAssignment())
		{
			insertWS(spaceCount);
			return;
		}
	}
	
	insertWS(mPrinter.isInParameterDecl() ? mPrinter.getAdvancedSpacesAroundAssignmentInOptionalParameters() : mPrinter.getSpacesAroundAssignment());
}

//this method is for inserting blank lines before elements, based on the format settings
private void insertLines(int amt, bool inCodeBlock)
{
    //don't add blank lines if not inside a block
	if (!mPrinter.isHardIndent())
	    return;
	//don't add blank lines if the wrapper is a labeled statement indent
	if (mPrinter.isLabeledIndent())
		return;
		
	//don't add blank lines if we are at start of block
	if (inCodeBlock)
	{
		if (!mPrinter.isCanAddCRsAtBlockStart() && mPrinter.isAtBlockStart())
		{
			return;
		}
	}
	
    for (int i=0;i<amt;i++)
    {
        mPrinter.insertCR(true);
    }
}

private void insertMaxColumnCR()
{
	mPrinter.insertCRBeyondMaxCol();
}

private void insertStatementCR()
{
	if (!mPrinter.isLabeledIndent())
		insertCR(false);
}

bool isFirstImport=true;
bool isFirstClassSeen=false;
bool isSeenPackage=false;
private void addBlankLinesBeforeFirstImport()
{
	//only add blank lines for before first import in 'package' area.  The assumption is that all the 
	// imports are together, or this setting doesn't really make sense.
	int linesToAdd=mPrinter.getBlankLinesBeforeImports();
	if (isFirstImport && !isFirstClassSeen && isSeenPackage)
	{
		isFirstImport=false;
		for (int i=0;i<linesToAdd;i++)
		{
			insertCR(true);
		}
	}
}
		
private void insertCR(bool overridE)
{
    mPrinter.insertCR(overridE);
}
	
private void pushLabeledIndent()
{
	pushExpressionIndent(); //push an expression indent so that it won't further indent the nested statement 
	mPrinter.makeLabeledIndent();
}
	
private void pushIndent(bool hardIndent)
{
	mPrinter.pushIndent(hardIndent ? ASPrettyPrinter.BRACE_INDENT : ASPrettyPrinter.STATEMENT_INDENT);
}

private void pushExpressionIndent()
{
	mPrinter.pushIndent(ASPrettyPrinter.EXPRESSION_INDENT);
}

private bool pushLazyParmIndent(bool alreadyPushed, int indentStyle)
{
	if (!alreadyPushed)
	{
		if (!mPrinter.isUseAdvancedWrapping() && indentStyle==WrapOptions.WRAP_STYLE_INDENT_TO_WRAP_ELEMENT)
			mPrinter.pushLazyIndent(ASPrettyPrinter.EXPRESSION_INDENT_NEXTITEM);
		else
			pushLazyIndent();
	}
	return true;
}

private void pushLazyIndent()
{
	mPrinter.pushLazyIndent(ASPrettyPrinter.EXPRESSION_INDENT);
}

private void popIndent()
{
    mPrinter.popIndent();
}
		
private void leftCurlyNewlineHandler(bool checkBraceIndent)
{
   if (mPrinter.isCRBeforeOpenBrace(mCodeBlockStack) || (checkBraceIndent && mPrinter.getIndentType(0)==ASPrettyPrinter.BRACE_INDENT))
   {
       insertCR(false);
       insertWS(1); //add a space here just in case newlines can't be added
   }
   else
       insertWS(1);
}
		
private void emit(IToken tok)
{
    mPrinter.emit(tok);
}
		    
		
public List<Exception> getParseErrors()
{
    return mParseErrors;
}
		
/*        bool isNotReservedWord(String name) {
        String[] reserveWords = new String[]
            {
                "as",
                "break",
                "case",
                "catch",
                "class",
                "const",
                "continue",
                "default",
                "delete",
                "do",
                "else",
                "extends",
                "false",
                "finally",
                "for",
                "function",
                "if",
                "implements",
                "import",
                "in",
                "instanceof",
                "interface",
                "internal",
                "is",
                "native",
                "new",
                "null",
                "package",
                "private",
                "protected",
                "public",
                "return",
                "super",
                "switch",
                "this",
                "throw",
                "to",
                "true",
                "try",
                "typeof",
                "use",
                "var",
                "void",
                "while",
                "with"
            };
        for (int i = 0; i<reserveWords.Length; i++) {
            if ( reserveWords[i] == name) {
                return false;
            }
        }
        return true;
    }
    */
    
/*    private void promoteEOL(ParserRuleReturnScope rule)
    {
        //System.out.println("start promoteEOL <<let HIDDENT IToken EOL be visible>>");
        IToken lt = input.LT(1);
        int index = lt.TokenIndex;
        if(index<0){
            index = input.Count;
        }
        int la = lt.Type;
        
        for (int ix = index - 1; ix >= 0; ix--){
            lt = input.Get(ix);
            int type = lt.Type;
            if (type == EOL || (type == COMMENT_MULTILINE && Regex.Matches(lt.Text, "/.*\r\n|\r|\n").Count > 0)){
                lt.setChannel(Token.DEFAULT_CHANNEL);
                input.seek(lt.TokenIndex);
                //System.out.println("promoteEOL : HIDDEN IToken ("+lt+") is set to DEFAULT");
                if (rule != null){
                    //System.out.println("promoteEOL :  startToken set as "+lt);
                    rule.Start = lt;
                }
                return;
            }else if(lt.Channel == Token.DEFAULT_CHANNEL){
                break;
            }
        }
        //System.out.println("");
    }
  */
    
    public const int CHANNEL_SLCOMMENT=43;
    public const int CHANNEL_MLCOMMENT=42;
    public const int CHANNEL_WHITESPACE=41;
    public const int CHANNEL_EOL=40;
    
    private bool promoteWhitespace()
    {
    	//find the current lookahead token
        IToken lt = input.LT(1);
        int index = lt.TokenIndex;
        if(index<0){
            index = input.Count;
        }

		//walk backward through tokens to see if the previous token is whitespace.
        for (int ix = index - 1; ix >= 0; ix--){
            lt = input.Get(ix);
            int channel=lt.Channel;
            if (channel == CHANNEL_EOL || channel ==  CHANNEL_WHITESPACE){
                return true;
            } else if(channel == Token.DEFAULT_CHANNEL){
                break;
            }
        }
        return false;
    }
}
// Lexer Helper Rule

fragment UNDERSCORE  : '_';
fragment DOLLAR      : '$';

fragment ALPHABET            :    'a'..'z'|'A'..'Z';

fragment NUMBER              :    '0' .. '9';   

fragment HEX_DIGIT           :    ('0' .. '9'|'a'..'f'|'A'..'F') ;

fragment CR                  :    '\r';

fragment LF                  :    '\n';

fragment UNICODE_ESCAPE      :    '\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;

//changed to accept any backslash escape because the compiler seems to be very lenient.
fragment ESCAPE_SEQUENCE     :   
							//	'\\' ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
                            //     |   UNICODE_ESCAPE
                            	 '\\' '\\'
                            	| '\\' ~('\\')
                                 ;
// Lexer Ignored Rule
EOL  
@after{
    debugMethod("EOL",$text);
}                        
    :    (CR LF | CR | LF)        
    { $channel = AS3_exParser.CHANNEL_EOL; };

WHITESPACE
@after{
    debugMethod("WHITESPACE",$text);
}
    :   (('\u0020'|'\u0009'|'\u000B'|'\u00A0'|'\u000C')|('\u001C'..'\u001F'))+              { $channel = AS3_exParser.CHANNEL_WHITESPACE; }
    ;
    
COMMENT_MULTILINE           
@after{
    debugMethod("COMMENT_MULTILINE",$text);
}
    :   '/*' ( options {greedy=false;} : . )* '*/'         { $channel = AS3_exParser.CHANNEL_MLCOMMENT; };

COMMENT_SINGLELINE
@after{
    debugMethod("COMMENT_SINGLELINE",$text);
}      
    :   '//' ~( CR | LF )* (CR LF | CR | LF)                          { $channel = AS3_exParser.CHANNEL_SLCOMMENT; };

// $<StringLiteral

SINGLE_QUOTE_LITERAL
@after{
    debugMethod("SINGLE_QUOTE_LITERAL",$text);
}          
    :   '\'' ( ESCAPE_SEQUENCE | ~('\\'|'\'') )* '\'';
DOUBLE_QUOTE_LITERAL         
@after{
    debugMethod("DOUBLE_QUOTE_LITERAL",$text);
} 
    :   '"'  ( ESCAPE_SEQUENCE | ~('\\'|'"') )* '"';

// $>

// $<RegularExpressionLiteral

REGULAR_EXPR_LITERAL
@after{
    debugMethod("REGULAR_EXPR_LITERAL",$text);
}
    :   {isRegularExpression()}? => DIV REGULAR_EXPR_BODY DIV REGULAR_EXPR_FLAG*
    ;
    
fragment REGULAR_EXPR_BODY
    :   REGULAR_EXPR_FIRST_CHAR REGULAR_EXPR_CHAR*
    ;   

// add > to the cannot be first char list
fragment REGULAR_EXPR_FIRST_CHAR
    :   ~(CR | LF |'*'|'\\'|'/') //|'>')
    |   BACKSLASH_SEQUENCE
    ;

fragment REGULAR_EXPR_CHAR
    :   ~(CR | LF |'\\'|'/')
    |   BACKSLASH_SEQUENCE
    ;

fragment BACKSLASH_SEQUENCE:    '\\' ~(CR | LF);    
    
fragment REGULAR_EXPR_FLAG :    IDENT_PART ;

// $>

// $<NumberLiteral

HEX_NUMBER_LITERAL           
@after{
    debugMethod("HEX_NUMBER_LITERAL",$text);
} 
    : '0' ('X'|'x') HEX_DIGIT+ ;

fragment DEC_NUMBER          :  NUMBER+ '.' NUMBER* | '.' NUMBER+ | NUMBER+ ;

DEC_NUMBER_LITERAL
@after{
    debugMethod("DEC_NUMBER_LITERAL",$text);
} 
    :  DEC_NUMBER EXPONENT? ;

fragment EXPONENT            : ('e'|'E') ('+'|'-')? NUMBER+ ;

// $>

IDENTIFIER
@after{
    debugMethod("Identifier",$text);
} 
    :   IDENT_NAME_ASCII_START
    |   UNICODE_ESCAPE+
    |   {consumeIdentifierUnicodeStart();}
    ;
       
fragment IDENT_NAME_ASCII_START   : IDENT_ASCII_START IDENT_PART*;

fragment IDENT_ASCII_START        : ALPHABET | DOLLAR | UNDERSCORE;
    
fragment IDENT_PART 
@after{
    debugMethod("IDENT_PART",$text);
} 
    :   (IDENT_ASCII_START) => IDENT_ASCII_START
    |   NUMBER
    |   {isUnicodeIdentifierPart(input.LA(1))}? {/*matchAny();*/}
    ;
    
XML_COMMENT
@after{
    debugMethod("XML_COMMENT",$text);
}                  
    :   '<!--' ( options {greedy=false;} : . )* '-->';
    
XML_CDATA options {k=8;}
@after{
    debugMethod("XML_CDATA",$text);
}    
    :   '<![CDATA' ( options {greedy=false;} : . )* ']]>' ;
     
XML_PI
@after{
    debugMethod("XML_PI",$text);
}                      
    :   '<?' ( options {greedy=false;} : . )* '?>'; 

// SourceCharacters but no embedded left-curly { or less-than <    
XML_TEXT 
@after{
    debugMethod("XMLText",$text);
}   
    : '\u0020'..'\u003b'
    | '\u003d'..'\u007a'
    | '\u007c'..'\u007e'
    | {isXMLText(input.LA(1))}?{/*matchAny();*/}
    ;

    
// $<Literal

booleanLiteral                     :   T=TRUE {emit($T);} | F=FALSE{emit($F);} ;

numericLiteral                     :   D=DEC_NUMBER_LITERAL {emit($D);} | H=HEX_NUMBER_LITERAL {emit($H);};

stringLiteral                      :   S=SINGLE_QUOTE_LITERAL{emit($S);} | D=DOUBLE_QUOTE_LITERAL {emit($D);};

regularExpresionLiteral            :   R=REGULAR_EXPR_LITERAL {emit($R);};

identifierLiteral                  :   /*{isNotReservedWord(input.LT(1).Text)}?*/ I=IDENTIFIER{emit($I);} | notQuiteReservedWord ; 

xmlNameLiteral                     :   (I=IDENTIFIER{emit($I);} | allKeywords) ( {!promoteWhitespace()}?=> (s=SUB {emit($s);} | d=DOT {emit($d);} | c=COLON {emit($c);}) {!promoteWhitespace()}?=> (I2=IDENTIFIER {emit($I2);} | allKeywords))*
									; 

literal                            :   N=NULL {emit($N);} | booleanLiteral | numericLiteral | stringLiteral | regularExpresionLiteral;
// $>

xmlMarkup                          :   xmlComment | xmlCDATA | xmlPI;
xmlComment                         :   x=XML_COMMENT {emit($x);} ;  
xmlCDATA                           :   x=XML_CDATA {emit($x);}; 
xmlPI                              :   x=XML_PI {emit($x);} ; 
xmlExprEval                        :   L=LCURLY {emit($L);pushIndent(true);} expression R=RCURLY{popIndent();emit($R);} ; 


xmlTextElement
    :
		allKeywords {/*TODO: see if I can change token type*/} 
    | lexToken=(   DEC_NUMBER_LITERAL 
    | 	HEX_NUMBER_LITERAL
    |   SINGLE_QUOTE_LITERAL 
    | 	DOUBLE_QUOTE_LITERAL
    |   IDENTIFIER 
    |   XML_TEXT  //used to have a '+' on this item
    |   DIV 
    | 	SEMI 
//    | 	LCURLY //not allowed in xml text
    | 	RCURLY 
    | 	LPAREN 
    | 	RPAREN 
    |	LBRACK 
    |	RBRACK      
    |	DOT         
    |	COMMA       
//    |	LT          //not allowed in xml text
    |	GT          
    |	LTE         
//    |	GTE         
    |	EQ          
    |	NEQ         
    |	SAME        
    |	NSAME       
    |	PLUS        
    |	SUB         
    |	STAR        
    |	MOD         
    |	INC         
    |	DEC         
    |	SHL         
//    |	SHR         
//    |	SHU         
    |	AND         
    |	OR          
    |	XOR         
    |	NOT         
    |	INV         
    |	LAND        
    |	LOR         
    |	QUE         
    |	COLON       
    |	ASSIGN      
//    |	UNDERSCORE  
//    |	DOLLAR      
//    |	MUL_ASSIGN
    |	DIV_ASSIGN
    |	MOD_ASSIGN
    |	ADD_ASSIGN
    |	SUB_ASSIGN
    |	SHL_ASSIGN
//    |	SHR_ASSIGN
//    |	SHU_ASSIGN
    |	AND_ASSIGN
    |	XOR_ASSIGN
    |	OR_ASSIGN
    |   LOR_ASSIGN
    |   LAND_ASSIGN
    |	ELLIPSIS    
    |	XML_ELLIPSIS
    |	XML_NS_OP
    |	XML_AT
//    |	XML_LS_STD
 //   |	XML_LS_END
    ) 
    {
        lexToken.Type = XML_TEXT; 
        emit($lexToken);
    }
    ;

xmlText
    : 
    (xmlTextElement)+ 
    ;

// it's a helper rule,should not be a tree.
xmlPrimaryExpression 
    :   xmlPropertyIdentifier
    |   xmlInitialiser
    |   xmlListInitialiser
    ;                                                                      

/* 
    XMLPropertyIdentifier can be a primary expression, but also can be a propertySuffixReference
    see example
        :   var xml:XML = <soap:Envelope soap:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/>;
            var soapNS:Namespace = message.namespace("soap");
            trace(xml.@soapNS::encodingStyle); //-> it's a propertySuffixReference Call
            with(xml){
                trace(@soapNS::encodingStyle); //-> it's a primaryExpression Call
            }
*/
xmlPropertyIdentifier
      :   xmlAttributeIdentifier
      |   xmlQualifiedIdentifier
      |   s=STAR {emit($s);}                                    
      ;    

xmlAttributeIdentifier
    :   at=XML_AT {emit($at);} 
        (
           xmlQualifiedIdentifier
           | xmlPropertySelector
           | indexSuffix
        )                                                        
    ; 
    
xmlPropertySelector
    :   xmlNameLiteral 
    |   s=STAR {emit($s);}
    ;

xmlQualifiedIdentifier
    :   xmlPropertySelector  x=XML_NS_OP {wrapEmit($x, ASPrettyPrinter.Break_Other_Connectors_code);}                 
    (
        xmlPropertySelector
        | indexSuffix
    )
    {popIndent();}
    ;

xmlInitialiser
    :   xmlMarkup
    |   xmlElement
    ;
    
//xmlTagEnd
//	:
//	(('/' '>')=> t1='/' t2='>'
 //   { $t1.Line == $t2.Line && 
 //     $t1.CharPositionInLine + 1 == $t2.CharPositionInLine}?
  //	    -> XML_TEND) {t1.Text = "/>";}        
//	;
    
xmlElement
@init
{
	WrapOptions options=mPrinter.getXMLWrapOptions();
	bool pushedFormat=false;
	bool pushedWrapInfo=false;
}
    :
    {pushedFormat=pushFormatType(options, true);}
    {pushedWrapInfo=pushWrapInfo(options, true);}
    {emitCRForTag(options);}
    L=LT {emit($L);}{emitXMLBreak($L, true);}{pushIndent(true);} xmlTagName xmlAttributes? 
    (
        x=XML_TEND {emit($x);}
    //	te=xmlTagEnd
    	//{emit($te.Start);}
        {emitCRForTag(options);}
        {popIndent();}
        | 
        G=GT {emit($G);pushXMLTextContentFlag();} xmlElementContent[false]? 
        x=XML_E_TEND {popIndent();}{emit($x);}{if (!popXMLTextContentFlag()) emitXMLBreak($x, true);} 
        xmlTagName G=GT{emit($G);}{emitCRForTag(options);} 
    )
    {
	    if (pushedWrapInfo) mPrinter.popWrapContext();
	    if (pushedFormat)
	    	mPrinter.popFormatMode();
    }
    ; 
    
xmlAttributes
    :   xmlAttribute+
    ;      
    
xmlTagName
    :   xmlExprEval
	| xmlNameLiteral
    ; 

xmlAttribute
    :  {promoteWhitespace()}? {insertWS(1);} xmlTagName A=ASSIGN {emit($A);} 
    (
        xmlExprEval
        | stringLiteral
    )
    ;
       
xmlElementContent[bool crAfterTags]
    :  xmlElementContentHelper[crAfterTags]+
    ;

xmlElementContentHelper[bool crAfterTags]
    : xmlExprEval {if (crAfterTags) insertCR(false);setXMLTextContentFlag();}
    | xmlMarkup {if (crAfterTags) insertCR(false);}
    | xmlElement {if (crAfterTags) insertCR(false);}
    | {mPrinter.pushFormatMode(ASPrettyPrinter.FORMAT_INDENT);}xmlText{mPrinter.popFormatMode();} {if (crAfterTags) insertCR(false);setXMLTextContentFlag();}
	;

xmlListInitialiser
@init
{
	WrapOptions options=mPrinter.getXMLWrapOptions();
	bool pushedFormat=false;
}
    :
		{pushedFormat=pushFormatType(options, true);}    
        {insertCR(false);} x=XML_LS_STD 
  		{emit($x);}{insertCR(false);}{pushIndent(true);}
  		xmlElementContent[true]? 
  		{insertCR(false);} x=XML_LS_END {popIndent();}{emit($x);}{insertCR(false);}
	    {
		    if (pushedFormat)
		    	mPrinter.popFormatMode();
	    }
    ;

// semic rule
semic
@init
{
    // Mark current position so we can unconsume a RBRACE.
    int marker = input.Mark();
    // Promote EOL if appropriate
    bool onBrace=false;
    if (((IToken)retval.Start).Text != null && ((IToken)retval.Start).Text == "}")
    {
    	onBrace=true;
		if (state.backtracking>0)
		{
			retval.Stop=retval.Start;
		    return retval; //we don't want to consume the '}' during the prediction phase
		}    	
    }
    	
    if (findVirtualHiddenToken(retval))
    {
       retval.Stop=retval.Start;
       return retval;
    }
       
 //   promoteEOL(retval);
}
    :   S=SEMI{emit($S);} 
    |   E=EOF{emit($E);} 
    |   R=RCURLY { input.Rewind(marker); 
                    if (onBrace)
                    {
                         retval.Start=input.LT(-1);
                         retval.Stop=retval.Start;
                         retval.Tree=null;
                         return retval;
                    }
                 }
//    |   C=COMMENT_MULTILINE {emit($C);} // (with EOL in it)
//    |   {isNextTokenHiddenVirtualSemi(retval)}?  E=EOL {emit($E);} 
    ;


fileContents
	: (packageDeclaration? packageElement*) | EOF
	;

// $<Package Declaration

packageDeclaration
	:   p=PACKAGE {isSeenPackage=true;{insertCR(false);}emit($p);pushExpressionIndent();} ({insertWS(1);} type)? {popIndent();} 
	    l=LCURLY 
	    {
	  	   mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_package_code);
	       leftCurlyNewlineHandler(false);
	       emit($l);
	       {mPrinter.addDeclEqualsBlock();}
	       if (mPrinter.isIndentAtPackageLevel())
	          pushIndent(true);
	       mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
	    } 
	    packageElement* 
	    {
	    	if (mPrinter.isIndentAtPackageLevel())
	            popIndent();
	    } 
	    {mPrinter.popDeclEqualsBlock();}
	    r=RCURLY {insertCR(false);emit($r);popBlockStack();popBlockStack();}
	;
			
//this is for actionscript embedded within mxml.  I believe that the semantics are that the code in
//the mx:Script blocks are embedded inside a virtual class declaration, so anything that is normally
//allowed inside a class should be okay.  However, imports are okay too.
mxmlEmbedded
	:
		({insertCR(false);} conditionalCompilerOption 
			l=LCURLY
			{ 
				mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_Conditional_code);
				leftCurlyNewlineHandler(false);
	    		emit($l);pushIndent(true);
	    		mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
	    	}
			mxmlEmbedded
			{popIndent();} r=RCURLY {insertCR(false);emit($r);popBlockStack();popBlockStack();} 
	     | propertyDeclaration | functionDeclaration | statement | directive | interfaceFunctionDeclaration
	    )*  
	    EOF?
	;
				
packageElement
    :
    	{insertCR(false);} conditionalCompilerOption 
			l=LCURLY
			{ 
				mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_Conditional_code);
				leftCurlyNewlineHandler(false);
	    		emit($l);pushIndent(true);
	    		{mPrinter.addDeclEqualsBlock();}
	    		mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
	    	}
			packageElement*
			{mPrinter.popDeclEqualsBlock();}
			{popIndent();} r=RCURLY {insertCR(false);emit($r);popBlockStack();popBlockStack();}	   
    	| classOrInterfaceDecl | propertyDeclaration | functionDeclaration | interfaceFunctionDeclaration | statement | directive
    ;

importDeclaration
	:
	{mPrinter.markDeclEqualsContextChange();}   
	{insertCR(false);addBlankLinesBeforeFirstImport();} i=IMPORT {emit($i);} type (D=DOT {emit($D);} S=STAR{emit($S);} )? semic 
	;

classOrInterfaceDecl
	:   {mPrinter.setBindingContext(ASPrettyPrinter.BindingContext_Class);} (conditionalDirAndBindingDecls)? {pushLazyIndent();}{insertCR(false);}{insertLines(mPrinter.getBlankLinesBeforeClass(), false);isFirstClassSeen=true;} memberModifiers? (interfaceDeclaration | classDeclaration)
	;
	
directive
	:
	{pushLazyIndent();}{insertCR(false);}(bindingDecl | includeDirective | useNamespaceDirective | importDeclaration | /*namespaceDirective |*/ defaultXMLNamespaceDirective){popIndent();}
	;
	
conditionalDirAndBindingDecls
	: {insertCR(false);} 	
	  {mPrinter.markBindablePos(true);}
	  conditionalCompilerOption 
      {mPrinter.setBindableMode();}
	  ({insertCR(false);} bindingDecl)*
	;
	
xmlKeyword
	: {input.LT(1).Text.ToLower() == "xml"}? I=IDENTIFIER {emit($I);} 
	;
	
conditionalCompilerOption
	:
	identifierLiteral x=XML_NS_OP {emit($x);} identifierLiteral
	;
	
defaultXMLNamespaceDirective
@init
{
	bool pushedFormat=false;
    WrapOptions options=mPrinter.getExpressionWrapOptions();
}
	:
	{mPrinter.markDeclEqualsContextChange();}
	{pushedFormat=pushFormatType(options, true);} 
	D=DEFAULT {emit($D);} xmlKeyword 
	//namespace
	N=NAMESPACE {emit($N);} 
	A=ASSIGN {insertWS(mPrinter.getSpacesAroundAssignment());emit($A);insertWS(mPrinter.getSpacesAroundAssignment());} assignmentExpression semic
	{
   	    if (pushedFormat)
   	    {
   	    	mPrinter.popFormatMode();
   	    }
	} 
	;	
	
bindingDecl
@init
{bool bindable=false;
 bool pushedIndent=false;
	bool pushedFormat=false;
	bool pushedWrapInfo=false;
 WrapOptions options=mPrinter.getExpressionWrapOptions();
}
	:
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
	   L=LBRACK  
		  (XA=XML_AT)? I=IDENTIFIER 
		  	{
		  		bindable=mPrinter.isDirectiveForNextElement($I.Text);
		  		if (bindable)
		  			mPrinter.markBindablePos(false); //call this to mark position *before* we send any of the tokens to the printer
		  		emit($L); }
		  		{if (XA!=null)
		  		    emit($XA); 
		  		emit($I);
		  		mPrinter.setLastBindableTagName($I.Text);
		  	} 
		(L=LPAREN {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParensInArgumentLists());}
		     (bindingDeclArg (C=COMMA {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);} bindingDeclArg)*)? 
		R=RPAREN{insertWS(mPrinter.getAdvancedSpacesInsideParensInArgumentLists());emit($R);}
	       )? 
	   R=RBRACK{emit($R);} (s=SEMI {emit($s);})?
	   {
        	if (pushedWrapInfo)
        		mPrinter.popWrapContext();
	        if (pushedIndent)
    	    	popIndent();
    	    if (pushedFormat)
    	    {
    	    	mPrinter.popFormatMode();
    	    }
	   	if (bindable)
	   	{
	   		mPrinter.setBindableMode();
	   	}
	   } 
	;
	
includeDirective
	:
	{mPrinter.markDeclEqualsContextChange();} 
	I=INCLUDE{emit($I);} stringLiteral semic  
	;
	
bindingDeclArg
	:
	//TODO: figure out what's actually legal here
//	(I=IDENTIFIER {emit($I);} E=ASSIGN {emit($E);})? expression  
//	| I=IDENTIFIER{emit($I);} 
//	| T=TRUE {emit($T);} 
//	| F=FALSE{emit($F);}
   
    (eitherIdentifier E=ASSIGN {insertWS(mPrinter.getAdvancedSpacesAroundAssignmentInMetatags()); emit($E); insertWS(mPrinter.getAdvancedSpacesAroundAssignmentInMetatags());} )? 
	(
		stringLiteral | (P=PLUS {emit($P);} | S=SUB {emit($S);} )? numericLiteral | (eitherIdentifier (D=DOT {emit($D);} eitherIdentifier)* )  
	);

// $>

// $<Class / Interface Body

interfaceDeclaration
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
	:   
	    i=INTERFACE {emit($i);} type 
		(e=EXTENDS 
			{pushedWrapInfo=pushWrapInfo(options, true);} {wrapEmit($e, ASPrettyPrinter.Break_Keyword_code);} 
			typeList
			{if (pushedWrapInfo) mPrinter.popWrapContext();}{popIndent();} 
		)? 
		{popIndent();}
        interfaceBody
	;	

interfaceBody
	:   l=LCURLY 
	    {
	    	mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_interface_code);
	    	leftCurlyNewlineHandler(false);
	    	emit($l);pushIndent(true);
	    	{mPrinter.addDeclEqualsBlock();}
	    	mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
	    } 
	    interfaceElement* 
	    {popIndent();} 
	    {mPrinter.popDeclEqualsBlock();}
	    r=RCURLY {insertCR(false);emit($r);popBlockStack();popBlockStack();}
	;	

classDeclaration
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
	:	
	    c=CLASS {emit($c);} type 
		( E=EXTENDS 
			{pushedWrapInfo=pushWrapInfo(options, true);}{wrapEmit($E, ASPrettyPrinter.Break_Keyword_code);}
			type
			{if (pushedWrapInfo) mPrinter.popWrapContext();}{popIndent();}
		)? 
		( I=IMPLEMENTS 
			{pushedWrapInfo=pushWrapInfo(options, true);} {wrapEmit($I, ASPrettyPrinter.Break_Keyword_code);} 
			typeList
			{if (pushedWrapInfo) mPrinter.popWrapContext();}{popIndent();}
		)? 
		{popIndent();}
        classBody 
    ;  
    
  

classBody
	:   L=LCURLY 
		{
			mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_class_code);
			leftCurlyNewlineHandler(false);
			emit($L);pushIndent(true);
			{mPrinter.addDeclEqualsBlock();}
			mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
		} 
		classBodyElement* 
		{popIndent();} 
		{mPrinter.popDeclEqualsBlock();}
		R=RCURLY{insertCR(false);emit($R);popBlockStack();popBlockStack();} 
	;

// $>
	 
// $<Class/Interface Element

classBodyElement
    : (conditionalCompilerOption LCURLY)=>
  	    	{insertCR(false);} conditionalCompilerOption 
			l=LCURLY
			{ 
				mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_Conditional_code);
				leftCurlyNewlineHandler(false);
	    		emit($l);pushIndent(true);
	    		{mPrinter.addDeclEqualsBlock();}
	    		mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
	    	}
			classBodyElement*
			{popIndent();}
			{mPrinter.popDeclEqualsBlock();} 
			r=RCURLY {insertCR(false);emit($r);popBlockStack();popBlockStack();}	   
    | propertyDeclaration | functionDeclaration | statement | directive
	;

interfaceElement
    : (conditionalCompilerOption LCURLY)=>
   	    	{insertCR(false);} conditionalCompilerOption 
			l=LCURLY
			{ 
				mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_Conditional_code);
				leftCurlyNewlineHandler(false);
	    		emit($l);pushIndent(true);
	    		{mPrinter.addDeclEqualsBlock();}
	    		mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
	    	}
			interfaceElement*
			{popIndent();}
			{mPrinter.popDeclEqualsBlock();} 
			r=RCURLY {insertCR(false);emit($r);popBlockStack();popBlockStack();}	   
    | propertyDeclaration | interfaceFunctionDeclaration | statement| directive
    ;

// $>
	 


// $<InterfaceFunction Declaration

interfaceFunctionDeclaration
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	bool pushedWrapInfo=false;
}
    :    {mPrinter.setBindingContext(ASPrettyPrinter.BindingContext_Function);} (conditionalDirAndBindingDecls)? {insertCR(false);} memberModifiers? F=FUNCTION {emit($F);}
       // getOrSet? 
    (S=SET{emit($S);} | G=GET{emit($G);} )?
    {pushedWrapInfo=pushWrapInfo(options, true);} 
	(I=IDENTIFIER {emit($I);} | notQuiteReservedWord) formalParameterList (C=COLON {insertWS(mPrinter.getAdvancedSpacesBeforeColonsInFunctionTypes()); emit($C);insertWS(mPrinter.getAdvancedSpacesAfterColonsInFunctionTypes());} type)? semic
    {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;

// $>

// $<Property Declaration

propertyDeclaration
	:    {insertLines(mPrinter.getBlankLinesBeforeProperties());mPrinter.setBindingContext(ASPrettyPrinter.BindingContext_Property);} (conditionalDirAndBindingDecls)? {insertCR(false);}{pushLazyIndent();} memberModifiers? (variableStatement | constantVarStatement | namespaceDirective ) {popIndent();}{mPrinter.adjustLastLineIndent();}
	;

// $>

// $<Function Definition (13)

functionDeclaration
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	bool pushedWrapInfo=false;
}
    :
    {mPrinter.setBindingContext(ASPrettyPrinter.BindingContext_Function);} (conditionalDirAndBindingDecls)? {pushLazyIndent();}{insertCR(false);insertLines(mPrinter.getBlankLinesBeforeFunction());} memberModifiers? F=FUNCTION {emit($F);}
    {mPrinter.checkForSingleLineFunctionMode($F);}    
    (funcType=(SET|GET) {emit($funcType);})?
    {pushedWrapInfo=pushWrapInfo(options, true);} 
	(I=IDENTIFIER {emit($I);} | notQuiteReservedWord) formalParameterList (C=COLON {insertWS(mPrinter.getAdvancedSpacesBeforeColonsInFunctionTypes());emit($C);insertWS(mPrinter.getAdvancedSpacesAfterColonsInFunctionTypes());} type)? {popIndent();mIsFunctionDecl=true;}
    {if (pushedWrapInfo) mPrinter.popWrapContext();}
    functionBody 
    {mPrinter.endSingleLineFunctionMode();}    
    ;

functionExpression
		//pop the indent to remove the lazy indent that is added by the surrounding expression.  Then add an indent
		//back at the end so that when the surrounding expression pops it will leave the correct number of indents.  Yuck.
	:   F=FUNCTION {emit($F);pushIndent(false);} (I=IDENTIFIER{emit($I);})? formalParameterList (C=COLON {insertWS(mPrinter.getAdvancedSpacesBeforeColonsInFunctionTypes());emit($C);insertWS(mPrinter.getAdvancedSpacesAfterColonsInFunctionTypes());} type)? {mIsFunctionDecl=false;} {popIndent();} 
			{mPrinter.pushFunctionExpressionStatementIndent();}	functionBody {popIndent();} 
    ;

formalParameterList
@init
{
	WrapOptions options=mPrinter.getMethodDeclWrapOptions();
	bool pushedFormat=false;
	bool pushedIndent=false;
	bool pushedWrapInfo=false;
	int firstParm=0;
}
    :   
		{
			mInFunctionParameterDecl=true;
			pushedFormat=pushFormatType(options, true);
			mPrinter.setInParameterDecl(true);
			pushedWrapInfo=pushWrapInfo(options, true);
		}
		L=LPAREN {insertWS(mPrinter.getSpacesBeforeFormalParameters());}{emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParensInParameterLists());}
        ( ( {pushedIndent=pushLazyParmIndent(pushedIndent, options.getIndentStyle());} {mPrinter.captureNextTextPosition();} variableDeclaration {firstParm=mPrinter.getLastCapturePosition();} 
            ( 
               C=COMMA 
               {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, firstParm, ASPrettyPrinter.Break_SubType_Parameters);}
               variableDeclaration 
            )* 
            ( C=COMMA  {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, firstParm, ASPrettyPrinter.Break_SubType_Parameters);} formalEllipsisParameter)?
           )
           | {pushedIndent=pushLazyParmIndent(pushedIndent, options.getIndentStyle());} formalEllipsisParameter
        )? 
		R=RPAREN {insertWS(mPrinter.getAdvancedSpacesInsideParensInParameterLists());emit($R);}
        
        {
        	 mPrinter.setInParameterDecl(false);
        	if (pushedWrapInfo)
        		mPrinter.popWrapContext();
	        if (pushedIndent)
    	    	popIndent();
    	    if (pushedFormat)
    	    {
    	    	mPrinter.popFormatMode();
    	    }
    	    mInFunctionParameterDecl=false;
        } 
    ;
    
formalEllipsisParameter
    :   E=ELLIPSIS  {emit($E);insertWS(1);} variableIdentifierDecl
    ;   

functionBody
@init
{
	bool containsStatements=false;
}
    :   L=LCURLY 
    	{
    		mCodeBlockStack.Add(mIsFunctionDecl ? ASPrettyPrinter.BraceContext_functionDecl_code : ASPrettyPrinter.BraceContext_functionExpression_code);
    		leftCurlyNewlineHandler(false);
    		emit($L);pushIndent(true);
    		{mPrinter.addDeclEqualsBlock();}
    		mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
    		insertLines(mPrinter.getBlankLinesToStartFunctions(), false);
    	} 
    		((statement | functionDeclaration) {containsStatements=true;})* {popIndent();}
    		{if (containsStatements)
    			insertLines(mPrinter.getBlankLinesToEndFunctions(), false);
    		 else
				mPrinter.clearAddedWhitespace();    		 	
    		}
    		{mPrinter.popDeclEqualsBlock();} 
    	R=RCURLY   {insertCR(false);emit($R);popBlockStack();popBlockStack();} 
    ;

// $>

// $<Member Modifiers

memberModifiers
    :   memberModifier+
    ;

//each
//	: {input.LT(1).Text == "each"}? I=IDENTIFIER{emit($I);} 
//	;
	
memberModifier
    :   x=(
        DYNAMIC
    |   FINAL
    |   INTERNAL
    |   NATIVE
    |   OVERRIDE
    |   PRIVATE
    |   PROTECTED
    |   PUBLIC
    |   STATIC
    |   IDENTIFIER //this is to handle the case of namespaces, which apparently don't have to be before other modifiers
    ) {emit($x);}
    ;

// $>


// statement

// $<Statement

statement
    :
    	{mStatementCount++;}
    (	{mPrinter.inOther();}{setBlockFlag(true);} blockStatement
    |   {insertStatementCR();}directive
    |   {insertStatementCR();}namespaceDirective
    |   {insertStatementCR();} {pushLazyIndent();}constantVarStatement {popIndent();}
    |   {markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());}tryStatement
    |   {markBlockFlag();} switchStatement
    |   {markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();}{mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);} withStatement {popBlockStack();}
    |   {pushLazyIndent();} returnStatement {popIndent();}
    |   {pushLazyIndent();} breakStatement {popIndent();}
    |   {pushLazyIndent();} continueStatement {popIndent();}
    |   {mPrinter.inLoop();}{markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();}{mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);} forStatement {popBlockStack();}
    |   {mPrinter.inLoop();}{markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();}{mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);} forInStatement {popBlockStack();}
    |   {mPrinter.inLoop();}{markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();}{mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);} forEachInStatement {popBlockStack();}
    |   {mPrinter.inLoop();}{markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();}{mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);} doWhileStatement {popBlockStack();}
    |   {mPrinter.inLoop();}{markBlockFlag();insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();}{mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);} whileStatement {popBlockStack();}
    |   {mPrinter.inCondition();}{insertLines(mPrinter.getBlankLinesBeforeControlStatement());} ifStatement
    |   {insertStatementCR();} {pushLazyIndent();} variableStatement {popIndent();}{mPrinter.adjustLastLineIndent();}
    |   {pushLazyIndent();} throwStatement {popIndent();}
    |   {insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();}{mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);} labelledStatement {popBlockStack();} 
    |   {pushLazyIndent();}{mPrinter.markDeclEqualsContextChange();} 
	    	{
	    		if (mPrinter.statementNeedsCR(input.LT(1)))
	    			insertStatementCR();
		    	else
		    		insertWS(1);
	    	} 
    		expression semic {popIndent();}{mPrinter.adjustLastLineIndent();}
    |   {if (mPrinter.isEmptyStatementsOnNewLine())insertStatementCR();} emptyStatement
    )
    	{mPrinter.inOther();}
    ;

// $>


// $<Block Statement

blockStatement
    :   ({insertCR(false);} conditionalToken=conditionalCompilerOption)? L=LCURLY 
    	{
    		if (conditionalToken!=null)
    			mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_Conditional_code);
    		leftCurlyNewlineHandler(conditionalToken==null); //if we have a conditional setting, then we want to have the option of keeping the brace on the same line
    		emit($L);}{pushIndent(true);
    		{mPrinter.addDeclEqualsBlock();}
    		mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
    	} 
    	statement* {popIndent();} 
    	{mPrinter.popDeclEqualsBlock();}
    	R=RCURLY {insertCR(false);emit($R);popBlockStack();if (conditionalToken!=null) popBlockStack();}
    ;

// $>

throwStatement
	: 	{mPrinter.markDeclEqualsContextChange();}
		T=THROW 
		{
			if (mPrinter.statementNeedsCR($T))
	    		insertStatementCR();
	    	else
	    		insertWS(1);
		}
		{emit($T);} expression semic
	;

// $<Constant Var Statement

constantVarStatement
    :
    {mInEqualAlignDecl=true;}   
    C=CONST  {emit($C);} variableDeclarationList (S=SEMI{emit($S);})?
    {mInEqualAlignDecl=false;}
    ; 
// $>


useNamespaceDirective
@init {
	bool pushedIndent=false;
	bool pushedFormat=false;
	bool pushedWrapInfo=false;
 WrapOptions options=mPrinter.getExpressionWrapOptions();
}
	:
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
    	{mPrinter.markDeclEqualsContextChange();}
	U=USE  {emit($U);} 
	N=NAMESPACE  {emit($N);} 
	qualifiedIdentifier (C=COMMA {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);} qualifiedIdentifier)* semic
	{
    	if (pushedWrapInfo)
    		mPrinter.popWrapContext();
        if (pushedIndent)
	    	popIndent();
	    if (pushedFormat)
	    {
	    	mPrinter.popFormatMode();
	    }
	}
	;    
// $<UseNamespace Statement

// $<Namespace Directive

namespaceDirective
    :   //(memberModifiers)? //namespace
    {mPrinter.markDeclEqualsContextChange();}
    N=NAMESPACE  {emit($N);}{pushExpressionIndent();} 
    qualifiedIdentifier ( A=ASSIGN  {insertWS(mPrinter.getSpacesAroundAssignment());emit($A);insertWS(mPrinter.getSpacesAroundAssignment());} stringLiteral )? semic {popIndent();}
    ;

// $>


// $<Try Statement(12.14)

tryStatement
    : 
    {mPrinter.markDeclEqualsContextChange();}
    {insertStatementCR();} T=TRY {emit($T);} {pushIndent(false);mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_try_code);} blockStatement {popIndent();popBlockStack();}
        ( catchClause+ finallyClause
        | catchClause+
        | finallyClause
        )
    ;

catchClause
	: {if (mPrinter.isCRBeforeCatch()) insertCR(false);}{insertWS(1);} C=CATCH {emit($C);insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());}{pushIndent(false);} L=LPAREN {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParensInParameterLists());} variableIdentifierDecl R=RPAREN {insertWS(mPrinter.getAdvancedSpacesInsideParensInParameterLists());emit($R);mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_catch_code);} blockStatement {popIndent();popBlockStack();}
    ;

finallyClause
    : {if (mPrinter.isCRBeforeCatch()) insertCR(false);}{insertWS(1);} F=FINALLY {emit($F);}{pushIndent(false);mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_finally_code);} blockStatement {popIndent();popBlockStack();}
    ;

// $>

// $<Labelled Statement(12.12)

labelledStatement
    :  I=IDENTIFIER {emit($I);}{pushLabeledIndent();} 
    	C=COLON 
    	{
    		emit($C);
    		insertWS(mPrinter.getSpacesAfterLabel());
    	} 
    	statement 
    	{popIndent();}
    ;

// $>

// $<switch Statement(12.11)

switchStatement
    :
    {mPrinter.markDeclEqualsContextChange();}  
    {insertLines(mPrinter.getBlankLinesBeforeControlStatement());}{insertStatementCR();} 
     S=SWITCH {emit($S);
     pushIndent(false);
     insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());}
     {pushExpressionIndent();} parExpression {popIndent();} 
    	L=LCURLY 
    	{
    		mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);
    		leftCurlyNewlineHandler(false);
    		emit($L);
    		if (mPrinter.isIndentSwitchCases())
    			pushIndent(true);
    		else
    			mPrinter.pushRelativeIndent(ASPrettyPrinter.BRACE_INDENT, -1);
    		{mPrinter.addDeclEqualsBlock();}
    		mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_block_code);
    	} 
    	switchBlockStatementGroup* {popIndent();}
    	{mPrinter.popDeclEqualsBlock();} 
    	R=RCURLY{insertCR(false);emit($R);popIndent();popBlockStack();popBlockStack();} 
    ;
    
///* The change here (switchLabel -> switchLabel+) technically makes this grammar
//   ambiguous; but with appropriately greedy parsing it yields the most
 //  appropriate AST, one in which each group, except possibly the last one, has
 //  labels and statements. */
switchBlockStatementGroup
@init
{
    int statementCount=0;
}
    :   {insertCR(false);} switchLabel {pushIndent(false);} 
    	{mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Switch);statementCount=mStatementCount;}
    	statement* 
         {mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Switch, mStatementCount-statementCount);}
    	{popIndent();}{insertCR(false);} breakStatement?
    ;
    
switchLabel
    :   C=CASE {emit($C);} {insertWS(1);} expression O=COLON 
    	{
    	emit($O);
    	insertWS(mPrinter.getSpacesAfterLabel());
    	} 
    |   D=DEFAULT {emit($D);} C=COLON
    		{
    			emit($C);
    			insertWS(mPrinter.getSpacesAfterLabel());
    		} 
    ;

// $>

// $<With statement(12.10)

withStatement
@init
{
	int statementStartInOutput=(-1);
	int statementEndInOutput=(-1);
    int statementCount=0;
}
    :   
    {mPrinter.markDeclEqualsContextChange();}
		W=WITH  {emit($W);statementStartInOutput=mPrinter.getCurrentOutputLength();insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());}{pushExpressionIndent();} L=LPAREN  {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());} expression  R=RPAREN  {insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());emit($R);statementEndInOutput=mPrinter.getCurrentOutputLength();}{popIndent();} {pushIndent(false);}
    	{mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Loop);
      	 mPrinter.captureStatementStart($W, statementStartInOutput);
    	 mPrinter.captureStatementEnd($R, statementEndInOutput);
    	 statementCount=mStatementCount;
    	} 
    	statement 
         {mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Loop, mStatementCount-statementCount);}
    	{popIndent();}
    ;

// $>

// $<Return statment (12.9)

returnStatement
    :   R=RETURN 
    	{
    		if (mPrinter.statementNeedsCR($R))
	    		insertStatementCR();
	    	else
	    		insertWS(1);
    	}
    	{emit($R);} ( {insertWS(1);} expression)? semic 
    ;

// $>


// $<Break statement (12.8)

breakStatement
    :   B=BREAK    
    	{
    		if (mPrinter.statementNeedsCR($B))
    			insertStatementCR();
	    	else
	    		insertWS(1);
    	}
    	{emit($B);} (I=IDENTIFIER{emit($I);})? semic
    ;

// $>


// $<Continue statement (12.7)

continueStatement
    :   C=CONTINUE
    	{
    		if (mPrinter.statementNeedsCR($C))
    			insertStatementCR();
	    	else
	    		insertWS(1);
    	} 
    	{emit($C);} (I=IDENTIFIER{emit($I);})? semic
    ;

// $>


// $<For statement 12.6

forStatement
@init
{
	int statementStartInOutput=(-1);
	int statementEndInOutput=(-1);
    int statementCount=0;
}
    :
    	{mPrinter.markDeclEqualsContextChange();}
		F=FOR {emit($F);statementStartInOutput=mPrinter.getCurrentOutputLength();insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());} {pushExpressionIndent();} L=LPAREN {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());} forControl R=RPAREN {insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());emit($R);}{popIndent();}{pushIndent(false);statementEndInOutput=mPrinter.getCurrentOutputLength();}
    	{mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Loop);
    	 mPrinter.captureStatementStart($F, statementStartInOutput);
    	 mPrinter.captureStatementEnd($R, statementEndInOutput);
    	 statementCount=mStatementCount;
    	} 
    	statement 
         {mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Loop, mStatementCount-statementCount);}
    	{popIndent();}
    ;
    
forInStatement
@init
{
	int statementStartInOutput=(-1);
	int statementEndInOutput=(-1);
    int statementCount=0;
}
    :
    	{mPrinter.markDeclEqualsContextChange();}
		F=FOR {emit($F);statementStartInOutput=mPrinter.getCurrentOutputLength();insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());} {pushExpressionIndent();} L=LPAREN {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());} forInControl R=RPAREN {insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());emit($R);} {popIndent();} {pushIndent(false);statementEndInOutput=mPrinter.getCurrentOutputLength();}
    	{mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Loop);
    	 mPrinter.captureStatementStart($F, statementStartInOutput);
    	 mPrinter.captureStatementEnd($R, statementEndInOutput);
    	 statementCount=mStatementCount;
    	} 
    	statement 
         {mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Loop, mStatementCount-statementCount);}
    	{popIndent();}
    ;  
    
forEachInStatement
@init
{
	int statementStartInOutput=(-1);
	int statementEndInOutput=(-1);
    int statementCount=0;
}
    :
    {mPrinter.markDeclEqualsContextChange();}
       F=FOR {emit($F);statementStartInOutput=mPrinter.getCurrentOutputLength();} {pushExpressionIndent();}
     //   each 
    E=EACH {emit($E);insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());} 
	L=LPAREN {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());} forInControl R=RPAREN {insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());emit($R);statementEndInOutput=mPrinter.getCurrentOutputLength();}{popIndent();}{pushIndent(false);}
   	{mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Loop);
     mPrinter.captureStatementStart($F, statementStartInOutput);
     mPrinter.captureStatementEnd($R, statementEndInOutput);
     statementCount=mStatementCount;
   	} 
    statement 
     {mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Loop, mStatementCount-statementCount);}
    {popIndent();}     
	;
forControl
options {k=3;} // be efficient for common case: for (ID ID : ID) ...
    :   forInit? {insertWS(mPrinter.getSpacesBeforeComma());} semic  {insertWS(mPrinter.getSpacesAfterComma());} expression? {insertWS(mPrinter.getSpacesBeforeComma());}semic {insertWS(mPrinter.getSpacesAfterComma());} forUpdate?
    ;

forInControl
options {k=3;} // be efficient for common case: for (ID ID : ID) ...
    :   forInDecl I=IN {insertWS(1);emit($I);} expression
    ;

forInDecl
    :   leftHandSideExpression
    |   V=VAR {emit($V);} variableDeclarationNoIn
    ;

forInit
    :   V=VAR{emit($V);} variableDeclarationNoInList
    |   expressionNoIn
    ;

forUpdate
    :   expression
    ;

// $>


// $<While statement (12.5)

doWhileStatement
@init
{
	int statementCount=0;
}
    :
    {mPrinter.markDeclEqualsContextChange();}
       D=DO {emit($D);} {pushIndent(false);} 
    	{mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Loop);statementCount=mStatementCount;} 
    	statement 
         {mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Loop, mStatementCount-statementCount);}
    	{popIndent();}{insertWS(1);}  
    	{
          if (mPrinter.isCRBeforeWhile() || !mPrinter.didLastStatementHaveBraces()) //add CR if explictly asked for or if there were no statement braces   
              insertCR(false);
    	} 
    	W=WHILE {emit($W);{pushExpressionIndent();}insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());} parExpression semic (S=SEMI{emit($S);})? {popIndent();}
    ;

// $>

// $<While statement (12.5)

whileStatement
@init
{
	int statementStartInOutput=(-1);
	int statementEndInOutput=(-1);
	int statementCount=0;
	IToken endToken=null;
}
    :
       {mPrinter.markDeclEqualsContextChange();}
       W=WHILE {emit($W);statementStartInOutput=mPrinter.getCurrentOutputLength();insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());}{pushExpressionIndent();} parExpression {endToken=input.LT(-1);statementEndInOutput=mPrinter.getCurrentOutputLength();popIndent();} {pushIndent(false);} 
    	{mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Loop);
    	 mPrinter.captureStatementStart($W, statementStartInOutput);
    	 mPrinter.captureStatementEnd(endToken, statementEndInOutput);
    	 statementCount=mStatementCount;
    	} 
    	statement 
         {mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Loop, mStatementCount-statementCount);}
    	{popIndent();}
    ;
    
// $>



// $<If statement (12.5)

ifStatement
@init 
{
   IToken tok=null;
   bool ifOnSameLine=false;
   bool wasBlock=false;
   bool needCloseBrace=false;
   int statementStartInOutput=(-1);
   int statementEndInOutput=(-1);
   int statementCount=0;
   IToken endToken=null;
}
    :
    	{mPrinter.markDeclEqualsContextChange();}      
        {
           tok=mPrinter.getLastToken(); 
           //if the previous token was not an else, then insert a CR.  Also if it is an 'else' but the setting says to put the 'if' on a new line
           if (!mPrinter.isKeepElseIfOnSameLine() || (tok==null) || tok.Text != "else")
           {
           		insertStatementCR();
           }

           if (tok!=null && tok.Text == "else")
           {
           		mPrinter.setElseIfState();
           }
        } 
         I=IF 
         {
              emit($I);
              statementStartInOutput=mPrinter.getCurrentOutputLength();
              ifOnSameLine=mPrinter.getElseIfNeedToLoseIndent();
              if (ifOnSameLine)
                  popIndent();
              insertWS(mPrinter.getSpacesBetweenControlKeywordsAndParens());
         }
         {pushExpressionIndent();} 
         parExpression 
         {endToken=input.LT(-1);statementEndInOutput=mPrinter.getCurrentOutputLength();}
         {popIndent();}
         {pushIndent(false);}
         {addIfElseBlockTracker();setBlockFlag(false);clearBlockFlag();}
         {mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);}
		 {mPrinter.addOpenBrace(input, ASPrettyPrinter.BraceAdd_Conditional);
    	  mPrinter.captureStatementStart($I, statementStartInOutput);
    	  mPrinter.captureStatementEnd(endToken, statementEndInOutput);
    	  statementCount=mStatementCount;
		 }
         statement
         {mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Conditional, mStatementCount-statementCount);}
         {popBlockStack();} 
         {wasBlock=isBlockFlag();popIfElseBlockTracker();}
         {popIndent();}
          
         (options {k=1;}:E=ELSE 
	         {
	          IToken tempTok=mPrinter.getLastToken();
	          if (mPrinter.isCRBeforeElse() || !wasBlock)//tempTok==null || tempTok.Text != "}") 
	              insertCR(false);
	         }
	         {insertWS(1);}
	         {emit($E);} 
	         {pushIndent(false);}{mCodeBlockStack.Add(ASPrettyPrinter.BraceContext_controlStatement_code);} 
	         {needCloseBrace=mPrinter.addOpenBraceForElse((CommonTokenStream)input);statementCount=mStatementCount;}
	         {mPrinter.inCondition();}
	         statement 
	         {if (needCloseBrace)
	         	mPrinter.addCloseBrace(input.LT(1), ASPrettyPrinter.BraceAdd_Conditional, mStatementCount-statementCount);}
	         {popBlockStack();}{popIndent();})?
			 {if (ifOnSameLine)
            	pushIndent(false);}
	          
    ;
    
// $>   
    

// $<Empty statement (12.3)

emptyStatement 
    :     S=SEMI {emit($S);} 
    ;

// $>


// $<Variable statement 12.2)

variableStatement
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	bool pushedFormat=false;
	bool pushedWrapInfo=false;
	bool pushedIndent=false;
}
    :
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
        (I=IDENTIFIER {emit($I);})? V=VAR {emit($V);mInEqualAlignDecl=true;} variableDeclaration {mInEqualAlignDecl=false;} ( C=COMMA {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);} variableDeclaration )* semic
    	{
    		if (pushedIndent)
    			popIndent();
	   	    if (pushedFormat)
	   	    {
	   	    	mPrinter.popFormatMode();
	   	    }
	   	    if (pushedWrapInfo)
	   	    	mPrinter.popWrapContext();
    	} 
    ;
    
variableDeclarationList
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	bool pushedFormat=false;
	bool pushedWrapInfo=false;
	bool pushedIndent=false;
}
    :
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
         variableDeclaration (  C=COMMA {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);} variableDeclaration)*
    	{
    		if (pushedIndent)
    			popIndent();
	   	    if (pushedFormat)
	   	    {
	   	    	mPrinter.popFormatMode();
	   	    }
	   	    if (pushedWrapInfo)
	   	    	mPrinter.popWrapContext();
    	}
    ;
    
variableDeclarationNoInList
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	bool pushedFormat=false;
	bool pushedWrapInfo=false;
	bool pushedIndent=false;
}
    :
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
        variableDeclarationNoIn ( C=COMMA {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);} variableDeclarationNoIn)*
    	{
    		if (pushedIndent)
    			popIndent();
	   	    if (pushedFormat)
	   	    {
	   	    	mPrinter.popFormatMode();
	   	    }
	   	    if (pushedWrapInfo)
	   	    	mPrinter.popWrapContext();
    	}
    ;
    
variableDeclaration
@init {
	WrapOptions options=mPrinter.getExpressionWrapOptions();
}
    :   variableIdentifierDecl ( A=ASSIGN 
    	{
    		insertVariableDeclAssignmentWhitespace($A, true);
    		{if (mInEqualAlignDecl) mPrinter.augmentDeclEqualPosition();}
    		wrapEmit($A, mInFunctionParameterDecl ? ASPrettyPrinter.Break_Parameter_Assignment_code : ASPrettyPrinter.Break_Assignment_code);
    		{if (mInEqualAlignDecl) mPrinter.captureDeclEqualPosition();}
    		insertVariableDeclAssignmentWhitespace($A, false);
    	} 
    	assignmentExpression {popIndent();})?
    ;

variableDeclarationNoIn
@init {
	WrapOptions options=mPrinter.getExpressionWrapOptions();
}
    :    variableIdentifierDecl ( A=ASSIGN 
         {
          insertVariableDeclAssignmentWhitespace($A, true);
          wrapEmit($A, ASPrettyPrinter.Break_Assignment_code);
          insertVariableDeclAssignmentWhitespace($A, false);
         } 
         assignmentExpressionNoIn {popIndent();})?
    ;
    
variableIdentifierDecl
	:    identifierLiteral ( C=COLON {insertWS(mPrinter.getAdvancedSpacesBeforeColonsInDeclarations());emit($C);insertWS(mPrinter.getAdvancedSpacesAfterColonsInDeclarations());} type )?
    ;
// $>
    
// $<Type / Type List

type:   qualifiedName | S=STAR {emit($S);} | V=VOID {emit($V);} ;

typeList
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	bool pushedFormat=false;
	bool pushedWrapInfo=false;
	bool pushedIndent=false;
}
    :
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
       type (C=COMMA {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);} type)*
    	{
    		if (pushedIndent)
    			popIndent();
	   	    if (pushedFormat)
	   	    {
	   	    	mPrinter.popFormatMode();
	   	    }
	   	    if (pushedWrapInfo)
	   	    	mPrinter.popWrapContext();
    	}
    ; 
// $>
     
standardQualifiedName
	:
	typeSpecifier (D=DOT {wrapEmit($D, ASPrettyPrinter.Break_Other_Connectors_code);} typeSpecifier {popIndent();})*
//	(I=IDENTIFIER {emit($I);} ) (D=DOT {emit($D);} (I=IDENTIFIER{emit($I);} ) )*
	;
	
qualifiedName 
    :   
    	standardQualifiedName (typePostfixSyntax)? 
    ;
    
typePostfixSyntax:
	D=DOT
	{emit($D);} 
//	{wrapEmit($D, ASPrettyPrinter.Break_Other_Connectors_code);} 
	L=LT {emit($L);} (standardQualifiedName | st=STAR {emit($st);}) (typePostfixSyntax)? G=GT {emit($G);}
	//{popIndent();}
	;
    
qualifiedIdentifier
    :   /*{isNotReservedWord(input.LT(1).Text)}?*/
    	I=IDENTIFIER {emit($I);} 
    ;


// Expression

parExpression
@init
{
	bool pushedWrap=false;
	WrapOptions options=mPrinter.getExpressionWrapOptions();
}
    :
    {pushedWrap=pushWrapInfo(options, true);}
	L=LPAREN  {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());} {pushExpressionIndent();} expression  R=RPAREN {insertWS(mPrinter.getAdvancedSpacesInsideParensInOtherPlaces());emit($R);} {popIndent();}
    {if (pushedWrap) mPrinter.popWrapContext();} 
    ;

expression
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	bool pushedFormat=false;
	bool pushedWrapInfo=false;
	bool pushedIndent=false;
}
    :   
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
    	assignmentExpression (  C=COMMA  {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);} assignmentExpression)*
    	{
    		if (pushedIndent)
    			popIndent();
	   	    if (pushedFormat)
	   	    {
	   	    	mPrinter.popFormatMode();
	   	    }
	   	    if (pushedWrapInfo)
	   	    	mPrinter.popWrapContext();
    	}
    ;

expressionNoIn
@init{
	WrapOptions options=mPrinter.getExpressionWrapOptions();
	bool pushedFormat=false;
	bool pushedWrapInfo=false;
	bool pushedIndent=false;
}
    :
    	{pushedFormat=pushFormatType(options, true);
    	 pushedWrapInfo=pushWrapInfo(options, true);
    	}
       assignmentExpressionNoIn (  C=COMMA  {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, -1, ASPrettyPrinter.Break_SubType_Other);} assignmentExpressionNoIn)*
    	{
    		if (pushedIndent)
    			popIndent();
	   	    if (pushedFormat)
	   	    {
	   	    	mPrinter.popFormatMode();
	   	    }
	   	    if (pushedWrapInfo)
	   	    	mPrinter.popWrapContext();
    	}
    ;

//11.13 Assignment Operators
assignmentExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :  
       {pushedWrapInfo=pushWrapInfo(options, true);} 
      (
      		(leftHandSideExpression  assignmentOperator)=> leftHandSideExpression  assignmentOperator  assignmentExpression
    	| conditionalExpression
       )
       {if (pushedWrapInfo)
	   	    mPrinter.popWrapContext();}
    ;


assignmentExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :  {pushedWrapInfo=pushWrapInfo(options, true);}
       (
    	   (leftHandSideExpression  assignmentOperator) => leftHandSideExpression  assignmentOperator  assignmentExpressionNoIn
    	|	conditionalExpressionNoIn
    	)
       {if (pushedWrapInfo)
	   	    mPrinter.popWrapContext();}
    ;

assignmentOperator
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
}
	: op=assignmentOperator_int 
	  {insertWS(mPrinter.getSpacesAroundAssignment());
	   emit((IToken)op.Start);
	   mPrinter.saveWrapChar((IToken)op.Start, ASPrettyPrinter.Break_Assignment_code, options.isBeforeAssignmentOperator(), false, -1, "");
	   insertWS(mPrinter.getSpacesAroundAssignment());
	  }
	;
	     
assignmentOperator_int
    : ASSIGN 
//    | MUL_ASSIGN
	| s=STAR a=ASSIGN! {s.Text = "*=";}
    | DIV_ASSIGN 
    | MOD_ASSIGN 
    | ADD_ASSIGN 
    | SUB_ASSIGN
    | SHL_ASSIGN
//    | SHR_ASSIGN
//    | SHU_ASSIGN 
/*    | (('<' '<' '=')=> t1='<' t2='<' t3='=' 
        { $t1.Line == $t2.Line &&
          $t1.CharPositionInLine + 1 == $t2.CharPositionInLine && 
          $t2.Line == $t3.Line && 
          $t2.CharPositionInLine + 1 == $t3.CharPositionInLine }?
      -> SHL_ASSIGN){ t1.Text = "<<=";} */
    |   (('>' '>' '=')=> t1='>' t2='>' t3='='
        { $t1.Line == $t2.Line && 
          $t1.CharPositionInLine + 1 == $t2.CharPositionInLine && 
          $t2.Line == $t3.Line && 
          $t2.CharPositionInLine + 1 == $t3.CharPositionInLine }?
      -> SHR_ASSIGN) {t1.Text = ">>=";}

    | (('>' '>' '>' '=')=> t1='>' t2='>' t3='>' t4='='
        { $t1.Line == $t2.Line && 
          $t1.CharPositionInLine + 1 == $t2.CharPositionInLine &&
          $t2.Line == $t3.Line && 
          $t2.CharPositionInLine + 1 == $t3.CharPositionInLine &&
          $t3.Line == $t4.Line && 
          $t3.CharPositionInLine + 1 == $t4.CharPositionInLine }?
      -> SHU_ASSIGN) {t1.Text = ">>>=";}
    | AND_ASSIGN 
    | XOR_ASSIGN 
    | OR_ASSIGN
    | LOR_ASSIGN
    | LAND_ASSIGN
    ;

//11.12 Conditional Operator ( ?: )
conditionalExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        logicalORExpression ( Q=QUE  {indentEmit($Q, ASPrettyPrinter.Break_Ternary_code);} assignmentExpression  {popIndent();} C=COLON  {indentEmit($C, ASPrettyPrinter.Break_Ternary_code);} assignmentExpression {popIndent();})?
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
conditionalExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        logicalORExpressionNoIn ( Q=QUE {indentEmit($Q, ASPrettyPrinter.Break_Ternary_code);} assignmentExpression  {popIndent();} C=COLON  {indentEmit($C, ASPrettyPrinter.Break_Ternary_code);} assignmentExpression {popIndent();})?
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;    
    
//11.11 Binary Logical Operators
logicalORExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        logicalANDExpression ( L=LOR {indentEmit($L, ASPrettyPrinter.Break_Logical_Ops_code);} logicalANDExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ; 
    
logicalORExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        logicalANDExpressionNoIn ( L=LOR {indentEmit($L, ASPrettyPrinter.Break_Logical_Ops_code);} logicalANDExpressionNoIn {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;     
    
logicalANDExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        bitwiseORExpression ( L=LAND {indentEmit($L, ASPrettyPrinter.Break_Logical_Ops_code);} bitwiseORExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
logicalANDExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        bitwiseORExpressionNoIn ( L=LAND {indentEmit($L, ASPrettyPrinter.Break_Logical_Ops_code);} bitwiseORExpressionNoIn {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;    
    
//11.10 Binary Bitwise Operators
bitwiseORExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        bitwiseXORExpression ( O=OR {indentEmit($O, ASPrettyPrinter.Break_Arithmetic_Ops_code);} bitwiseXORExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
bitwiseORExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        bitwiseXORExpressionNoIn ( O=OR {indentEmit($O, ASPrettyPrinter.Break_Arithmetic_Ops_code);} bitwiseXORExpressionNoIn {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;    
    
bitwiseXORExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        bitwiseANDExpression ( x=XOR {indentEmit($x, ASPrettyPrinter.Break_Arithmetic_Ops_code);} bitwiseANDExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
bitwiseXORExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        bitwiseANDExpressionNoIn ( x=XOR {indentEmit($x, ASPrettyPrinter.Break_Arithmetic_Ops_code);} bitwiseANDExpressionNoIn {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;    

bitwiseANDExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        equalityExpression ( A=AND {indentEmit($A, ASPrettyPrinter.Break_Arithmetic_Ops_code);} equalityExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
bitwiseANDExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        equalityExpressionNoIn ( A=AND {indentEmit($A, ASPrettyPrinter.Break_Arithmetic_Ops_code);} equalityExpressionNoIn {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;    

//11.9 Equality Operators
equalityExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        relationalExpression ( eq=(EQ|NEQ|SAME|NSAME){indentEmit($eq, ASPrettyPrinter.Break_Arithmetic_Ops_code);}  relationalExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
equalityExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        relationalExpressionNoIn ( eq=(EQ|NEQ|SAME|NSAME) {indentEmit($eq, ASPrettyPrinter.Break_Arithmetic_Ops_code);}  relationalExpressionNoIn {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;    

//11.8 Relational Operators
relationalExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        shiftExpression 
    	(
	    	( g=GT (assign=ASSIGN)? 
		        {if (assign!=null)
		         {
		         	g.Text = ">=";
		         	g.Type = GTE;
		         }
		         indentEmit($g, ASPrettyPrinter.Break_Arithmetic_Ops_code);
		        } 
	          | eq=(IN|LT|LTE|INSTANCEOF|IS|AS) {indentEmit($eq, ASPrettyPrinter.Break_Arithmetic_Ops_code);}
	        )  
	        shiftExpression {popIndent();}
        )*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
relationalExpressionNoIn
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        shiftExpression 
    	(
	    	( g=GT (assign=ASSIGN)? 
		        {if (assign!=null)
		         {
		         	g.Text = ">=";
		         	g.Type = GTE;
		         }
		         indentEmit($g, ASPrettyPrinter.Break_Arithmetic_Ops_code);
		        } 
	          | eq=(LT|LTE|INSTANCEOF|IS|AS) {indentEmit($eq, ASPrettyPrinter.Break_Arithmetic_Ops_code);}
	        )  
	        shiftExpression {popIndent();}
        )*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;

//11.7 Bitwise Shift Operators
shiftExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        additiveExpression ( 
    		(
    			t1=SHL
    			/*(('<' '<' )=> t1='<' t2='<' 
        		{$t1.Line == $t2.Line &&
          		$t1.CharPositionInLine + 1 == $t2.CharPositionInLine }?
      			-> SHL) {t1.Text = "<<";}*/
      		|	(('>' '>')=> t1='>' t2='>'
        		{ $t1.Line == $t2.Line && 
          			$t1.CharPositionInLine + 1 == $t2.CharPositionInLine }?
      			-> SHR) {t1.Text = ">>";}
		    | 	(('>' '>' '>')=> t1='>' t2='>' t3='>'
        		{ $t1.Line == $t2.Line && 
          			$t1.CharPositionInLine + 1 == $t2.CharPositionInLine &&
          			$t2.Line == $t3.Line && 
          			$t2.CharPositionInLine + 1 == $t3.CharPositionInLine }?
      			-> SHU) {t1.Text = ">>>";}
    		) 
    		{indentEmit($t1, ASPrettyPrinter.Break_Arithmetic_Ops_code);} additiveExpression {popIndent();}
    	)*
    	{if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;

//11.6 Additive Operators
additiveExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        multiplicativeExpression ( op=(PLUS|SUB){indentEmit($op, ASPrettyPrinter.Break_Arithmetic_Ops_code);}  multiplicativeExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;

//11.5 Multiplicative Operators
multiplicativeExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    :   {pushedWrapInfo=pushWrapInfo(options, true);}
        unaryExpression ( op=(STAR|DIV|MOD){indentEmit($op, ASPrettyPrinter.Break_Arithmetic_Ops_code);} unaryExpression {popIndent();})*
        {if (pushedWrapInfo) mPrinter.popWrapContext();} 
    ;

//11.4 Unary Operators
unaryExpression
    :   postfixExpression
    |  op=(NOT | INV) {emit($op);} unaryExpression
    |   unaryOp postfixExpression
    
    
    ;

unaryOp
    :   op=(DELETE | VOID | TYPEOF | INC | DEC | PLUS | SUB | INV | NOT) {emit($op);}
    ;


//11.3 Postfix Expressions
postfixExpression
    :   leftHandSideExpression postfixOp?
    ;
    
postfixOp
    :   op=(INC | DEC){emit($op);}
    ;

//These rules came from a grammar by Patrick Hulsmeijer, posted to the ANTLR examples
memberExpression
	: primaryExpression
	| functionExpression
	| newExpression
	;

newExpression
	: N=NEW  {emit($N);insertWS(1);} primaryExpression
	;

//11.2
leftHandSideExpression
@init {
    WrapOptions options=mPrinter.getExpressionWrapOptions();
    bool pushedWrapInfo=false;
}
    : {pushedWrapInfo=pushWrapInfo(options, true);}
    memberExpression 
    (
      arguments
      | L=LBRACK {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideArrayReferenceBrackets());} expression R=RBRACK{insertWS(mPrinter.getAdvancedSpacesInsideArrayReferenceBrackets());emit($R);} 
//      | D=DOT {wrapEmit($D, ASPrettyPrinter.Break_Function_Calls_code);} (eitherIdentifier op=XML_NS_OP {wrapEmit($op, ASPrettyPrinter.Break_Other_Connectors_code);} {popIndent();})? eitherIdentifier {popIndent();}
//      | D=DOT {wrapEmit($D, ASPrettyPrinter.Break_Function_Calls_code);} eitherIdentifier {popIndent();}
      | E=XML_ELLIPSIS{wrapEmit($E, ASPrettyPrinter.Break_Other_Connectors_code);} eitherIdentifier {popIndent();}
      | D=DOT ({wrapEmit($D, ASPrettyPrinter.Break_Function_Calls_code);} eitherIdentifier | {wrapEmit($D, ASPrettyPrinter.Break_Other_Connectors_code);} parExpression) {popIndent();}
      | typePostfixSyntax
      | op=XML_NS_OP {wrapEmit($op, ASPrettyPrinter.Break_Other_Connectors_code);} expression {popIndent();}
    )*  // | x=XML_AT {emit($x);}
    {if (pushedWrapInfo) mPrinter.popWrapContext();}
    ;
    
eitherIdentifier
	: I=IDENTIFIER  {emit($I);} 
	 | xmlPropertyIdentifier
	 | allKeywords
	;
	
typeSpecifier:
	I=IDENTIFIER {emit($I);} | notQuiteReservedWord | I=INTERNAL {emit($I);} | D=DEFAULT {emit($D);}
	;
	
notQuiteReservedWord
	: 
	word=(TO | NATIVE | EACH | GET | SET | NAMESPACE | DYNAMIC | FINAL | OVERRIDE | STATIC ) {emit($word);}
	;

allKeywords
	: (reservedWord | notQuiteReservedWord)
	;
reservedWord
	:
    word=(AS          
    | BREAK           
    | CASE  
    | CATCH           
    | CLASS 
    | CONST
    | CONTINUE
    | DEFAULT
    | DELETE
    | DO
    | ELSE
    | EXTENDS
    | FALSE
    | FINALLY
    | FOR
    | FUNCTION
    | IF
	| IMPLEMENTS
    | IMPORT          
    | IN
    | INSTANCEOF      
    | INTERFACE
    | INTERNAL        
    | IS
//    | NATIVE          
    | NEW
    | NULL            
    | PACKAGE  
    | PRIVATE         
    | PROTECTED
    | PUBLIC          
    | RETURN
    | SUPER           
    | SWITCH
    | THIS            
    | THROW
	| TRUE
    | TRY             
    | TYPEOF
    | USE             
    | VAR
    | VOID            
    | WHILE
    | WITH 
//    | EACH            
// 	| GET
//    | SET             
//    | NAMESPACE
    | INCLUDE         
//    | DYNAMIC
//    | FINAL           
//    | OVERRIDE
//    | STATIC)
       ) 
       {emit($word);}      
	;
	
arguments
@init
{
	WrapOptions options=mPrinter.getMethodCallWrapOptions();
	bool pushedFormat=false;
	bool pushedIndent=false;
	bool pushedWrapInfo=false;
	int firstArgPos=0;
}
	: 
	  {pushedFormat=pushFormatType(options, true);
	   pushedWrapInfo=pushWrapInfo(options, true);
	  }
	L=LPAREN {{insertWS(mPrinter.getSpacesBeforeArguments());} emit($L);insertWS(mPrinter.getAdvancedSpacesInsideParensInArgumentLists());}
	  ( {pushedIndent=pushLazyParmIndent(pushedIndent, options.getIndentStyle());} {mPrinter.captureNextTextPosition();} assignmentExpression {firstArgPos=mPrinter.getLastCapturePosition();} 
	        (  
		        C=COMMA 
		        {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, firstArgPos, ASPrettyPrinter.Break_SubType_Arguments);}
		        assignmentExpression 
	        )* 
	  )? 
	R=RPAREN{insertWS(mPrinter.getAdvancedSpacesInsideParensInArgumentLists());emit($R);}
      {
        if (pushedIndent)
   	    	popIndent();
   	    if (pushedFormat)
   	    {
   	    	mPrinter.popFormatMode();
   	    }
   	    if (pushedWrapInfo)
   	    	mPrinter.popWrapContext();
      } 
	;

/*suffix helper rule*/ 
suffix
    :    indexSuffix | propertyReferenceSuffix
    ;
/*code like [i] or [1]*/     
indexSuffix             
    :    L=LBRACK  {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideArrayReferenceBrackets());} expression  R=RBRACK{insertWS(mPrinter.getAdvancedSpacesInsideArrayReferenceBrackets());emit($R);} 
    ;
    
propertyReferenceSuffix
    :    D=DOT  {wrapEmit($D, ASPrettyPrinter.Break_Other_Connectors_code);} I=IDENTIFIER{emit($I);} {popIndent();} 
    |    D=DOT  {wrapEmit($D, ASPrettyPrinter.Break_Other_Connectors_code);} xmlPropertyIdentifier {popIndent();}
    |    D=DOT  {wrapEmit($D, ASPrettyPrinter.Break_Other_Connectors_code);} {popIndent();} /*it's a xml only reference match*/
    ;

//11.1 Primary Expression
primaryExpression  
    :    primaryExpressionHelper
    ;
    
/* derived from ECMA-262 basicly. but add super alternative*/
primaryExpressionHelper
    :   T=THIS{emit($T);} 
    |   S=SUPER{emit($S);} 
    |   literal  
    |   arrayLiteral // ARRAY_LITERAL
    |   objectLiteral  // OBJECT_LITERAL
    |   (identifierLiteral x=XML_NS_OP {emit($x);})? identifierLiteral 
    |   xmlPrimaryExpression
    |   parExpression // PAR_EXPRESSION
    |   l=LT {emit($l);} type g=GT {emit($g);} (arrayLiteral)? //Vector initializer with optional array data
    ;

//11.1.5 Object Initialiser
objectLiteral
    :   L=LCURLY {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideObjectBraces());
    pushIndent(true);
    } propertyNameAndValueList? R=RCURLY {
    popIndent();
    insertWS(mPrinter.getAdvancedSpacesInsideObjectBraces());emit($R);} 
    ;

propertyNameAndValueList
@init
{
	WrapOptions options=mPrinter.getArrayInitWrapOptions();
	bool pushedFormat=false;
	bool pushedIndent=true; //so that we won't push another indent
	bool pushedWrapInfo=false;
	int firstItem=(-1);
}
    :
	  {pushedFormat=pushFormatType(options, true);
	   pushedWrapInfo=pushWrapInfo(options, true);
	  }
	   {mPrinter.captureNextTextPosition();}
       propertyNameAndValue 
       {firstItem=mPrinter.getLastCapturePosition();}
       		(C=COMMA {pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, firstItem, ASPrettyPrinter.Break_SubType_Object);} propertyNameAndValue)*
      {
//        if (pushedIndent)
//   	    	popIndent();
   	    if (pushedFormat)
   	    {
   	    	mPrinter.popFormatMode();
   	    }
   	    if (pushedWrapInfo)
   	    	mPrinter.popWrapContext();
      } 
    ;

propertyNameAndValue
    :   propertyName C=COLON 
    		{
    		emit($C);
    		insertWS(mPrinter.getSpacesAfterLabel());
    		} 
    		assignmentExpression
    ;

propertyName
    :   identifierLiteral 
    |   stringLiteral 
    |   numericLiteral 
    ;

//11.1.4 Array Initialiser
arrayLiteral
    :   L=LBRACK {emit($L);insertWS(mPrinter.getAdvancedSpacesInsideArrayDeclBrackets());} elementList? R=RBRACK{insertWS(mPrinter.getAdvancedSpacesInsideArrayDeclBrackets());emit($R);} 
    ;

elementList
@init
{
	WrapOptions options=mPrinter.getArrayInitWrapOptions();
	bool pushedFormat=false;
	bool pushedIndent=false;
	bool pushedWrapInfo=false;
	int firstItemPos=0;
}
    :
    	{pushedFormat=pushFormatType(options, true);}
    	{
		 pushedIndent=pushLazyParmIndent(pushedIndent, options.getIndentStyle());
    	 pushedWrapInfo=pushWrapInfo(options, true);}
        {mPrinter.captureNextTextPosition();} assignmentExpression {firstItemPos=mPrinter.getLastCapturePosition();} 
    	(
    		C=COMMA 
    		{pushedIndent=emitCommaWithSpacingAndCRs(options, $C, pushedIndent, firstItemPos, ASPrettyPrinter.Break_SubType_Array);}
    		assignmentExpression
    	)* (C=COMMA {emit($C);})? //allow extra comma on end, because it's apparently tolerated
    	
		{
			if (pushedIndent)
				popIndent();
    	    if (pushedFormat)
    	    {
    	    	mPrinter.popFormatMode();
    	    }
    	    if (pushedWrapInfo)
    	    	mPrinter.popWrapContext();
		} 
    ;
